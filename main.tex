\documentclass[11pt]{article}
\pdfoutput=1
\usepackage[margin=1in,a4paper]{geometry}
\usepackage{amsthm,amssymb,amsmath}  
\usepackage{xspace,enumerate}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks=true,urlcolor=Blue,citecolor=Green,linkcolor=BrickRed]{hyperref}
\usepackage[capitalise]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{authblk}


\def\dd{\mathinner{.\,.}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\tO}{\tilde{\mathcal{O}}}
\renewcommand{\phi}{\varphi}
\newcommand{\set}[1]{\left\lbrace #1 \right\rbrace}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\bigset}[1]{\big \lbrace #1 \big \rbrace}
\newcommand{\Bigset}[1]{\Big \lbrace #1 \Big \rbrace}
\newcommand{\eq}[1]{\begin{align*} #1 \end{align*}}
\DeclareMathOperator*{\Ham}{Ham}


\usepackage{microtype} %if unwanted, comment out or use option "draft"
\usepackage{amsmath,amsfonts}
\usepackage[cmbtt]{bold-extra}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{thm-restate}
\usepackage{comment}
\usepackage{forest}
\usepackage{xspace}
\usepackage{enumerate}
\usepackage{makecell}
\usepackage{listings}
\usepackage{multirow}
\usepackage{diagbox}
\usepackage{todonotes}
\usepackage{thmtools}
\usepackage[ruled,noline,noend]{algorithm2e}
\usepackage[capitalise]{cleveref}
\usepackage{graphics,adjustbox}
\usepackage{tabularx}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{verbatim}
\usepackage{braket}
\usepackage[noadjust]{cite}
\usepackage{xspace}
\usepackage{bold-extra}
\usepackage[margin=1in]{geometry}

\pagestyle{myheadings}


\title{Fast algorithm for two-dimensional pattern matching with $k$ mismatches}
\author[1]{Jonas Ellert}
\author[2]{Paweł Gawrychowski}
\author[3]{Adam Górkiewicz}
\author[4]{Tatiana Starikovskaya}
\affil[1]{?}
\affil[2]{?}
\affil[3]{?}
\affil[4]{?}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}  
\newtheorem{fact}{Fact}
\newtheorem{corollary}[fact]{Corollary}  
\newtheorem{observation}{Observation}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{remark}[definition]{Remark}
\newtheorem{conjecture}{Conjecture} 
\newtheorem*{claim}{Claim}
\newtheorem{problem}{Problem}
%\newcommand{\defproblem}[4]{\begin{center}\vspace{2mm}\noindent\fbox{\begin{minipage}{0.96\textwidth} \begin{problem}[#2] \label{#1} \ \\ {\bf{Input:}} #3 \\ {\bf{Output:}} #4 \end{problem} \end{minipage}} \vspace{2mm}\end{center}}
\newcommand{\defproblem}[3]{\begin{center}\vspace{2mm}\noindent\fbox{\begin{minipage}{0.96\textwidth} #1 \\ {\bf{INPUT:}} #2 \\ {\bf{OUTPUT:}} #3 \end{minipage}} \vspace{2mm}\end{center}}


\sloppy

\renewcommand{\vector}[2]{\begin{pmatrix} #1 \\ #2 \end{pmatrix}}
\DeclareMathOperator*{\ID}{Id}

% BEGIN DOCUMENT
\begin{document}

\date{}
\maketitle

\begin{abstract}
\end{abstract}

%\thispagestyle{empty}
%\clearpage
%\setcounter{page}{1}


% INTRODUCTION
\section{Introduction}


%\paragraph{bullshit}
%\paragraph{related work}
%\paragraph{our result}

\newcommand{\hd}{\textsc{HD1D}\xspace}
\newcommand{\HD}{\textsc{HD2D}\xspace}

We consider the one-dimensional all-substring Hamming distance problem (\hd), where for a given text string $T$ of length $n$ and a string $P$ of length $m$ ($m \le n$), we want to calculate the Hamming distance between $P$ and every fragment $T$ of length $m$.

We consider the two-dimensional all-substring Hamming distance problem (\HD), where for a given 2D string $T$ of size $n \times n$ and a string $P$ of size $m \times m$ ($m \le n$), we want to calculate the Hamming distance between $P$ and every $m \times m$ fragment of $T$.

We also consider the bounded variants of \hd and \HD, where we are only required to calculate the distances which are not greater than $k$, for some parameter $k \in \Z^+$.

\begin{fact}
	Bounded \hd can be solved in $\tO((m + k \sqrt{m})n / m)$ time.
\end{fact}


\begin{theorem}
	\label{main result}
	Bounded \HD can be solved in $\tO((m^2 + mk^{5/4})n^2 / m^2)$ time.
\end{theorem}


% PRELIMINARIES
\section{Preliminaries}

\renewcommand{\d}[1]{#1^\mathbf{d}}
\newcommand{\f}[1]{#1^\mathbf{f}}
\begin{definition}[Two-dimensional string]
	We define a \textbf{string} $S$ as an ordered pair $(\d{S}, \f{S})$ where $\d{S} \subseteq \Z^2$ is a finite set of two-dimensional integer vectors and $\f{S} : \d{S} \to \Sigma$
	is a function mapping the vectors to characters.
	For simplicity we will sometimes write $S(u)$ to denote $\f{S}(u)$ for $u \in \d{S}$.
	We will also sometimes write $u \in S$ to denote that $u \in \d{S}$.
	We define a \textbf{substring} of $S$ as a string $R$ such that $\d{R} \subseteq \d{S}$ and $R(u) = S(u)$ for all $u \in R$.
	We say that a string $S$ is \textbf{partitioned} into its substrings $R_1, \dots, R_\ell$ when the sets $\d{R_1}, \dots, \d{R_\ell}$ partition $\d{S}$.
	We call a string $S$ \textbf{monochromatic} if $\f{S}[\d{S}] = \set{\alpha}$ for some $\alpha \in \Sigma$.
	We say that $S$ is $n \times m$ for some integers $n, m > 0$ when $\d{S} = \set{0, \dots, n - 1} \times \set{0, \dots, m - 1}$.
\end{definition}


\begin{definition}[Shifting]
	For a set of vectors $V$ and a vector $u$, we denote $V + u$ as $\set{v + u : v \in V}$.
	For a string $S$ and a vector $u$, we denote $S + u$ as a string $R$ such that
	$\d{R} = \d{S} + u$ and $\f{R}(v) = \f{S}(v - u)$ for $v \in \d{R}$.
	Intuitively, we shift the set of vectors while maintaining their character values.
\end{definition}


\begin{definition}[Hamming distance]
	Consider two strings $S, R$. We define
	$$ \Ham(S, R) = |\set{u : u \in S, u \in R, S(u) \neq R(u)}|.$$
\end{definition}


\begin{definition}[Vector operators]
	For a vector $u \in \Z^2$ we refer to its coordinates as $x(u), y(u)$.
	For $u, v \in \Z^2$ we denote $u \cdot v = x(u) \cdot x(v) + y(u) \cdot y(v)$
	and $u \times v = x(u) \cdot y(v) - y(u) \cdot x(v)$.
	Note that alternatively $u \cdot v = |u||v| \cos \alpha$ and $u \times v = |u||v| \sin \alpha$ where $\alpha$ is the angle between $u$ and $v$.
\end{definition}


\newcommand{\Q}{\mathcal{Q}}
\begin{definition}[Quadrants]
	We define the four \textbf{quadrants} as
	\eq{
		\Q_1 = (0, +\infty) \times [0, +\infty), \quad
		\Q_2 = (-\infty, 0] \times (0, +\infty), \quad
		\Q_3 = (-\infty, 0) \times (-\infty, 0], \quad
		\Q_4 = [0, +\infty) \times (-\infty, 0).
	}
\end{definition}


\section{One-dimensional generalizations}
In this section we explore some of the methods used for one-dimensional strings.
Specifically, as our goal is to generalise the solution for pattern matching with $k$ mismatches described in \cite{Gawrychowski2017}, we are especially interested in two-dimensional variants of the techniques that were used to solve the one-dimensional case.


\begin{theorem}
	Consider an algorithm $\mathcal{A}$ which solves \HD (bounded or unbounded), but only when $2|n$ and $n \le \frac{3}{2}m$.
	If its running time is $\mathcal{T}(m)$, then there exists an algorithm which solves the general case in $\O(\mathcal{T}(m) n^2 / m^2)$.
	\begin{proof}
		Let $r = \floor{m / 2}$ and let $n' = r + m - 1$ or $r + m$ if $r + m - 1$ is odd.
		For any query vector $q$ consider a vector $u$ such that $r|u.x, r|u.y$ and $q - u \in \set{0, \dots, r - 1}^2$.
		We have $\Ham(P + q, T) = \Ham(P + q - u, T_u)$ where $\d{T_u} = \set{0, \dots, n' - 1}^2$, $\f{T_u} = \f{(T - u)}$.
		If $\f{T_u}$ is not defined for some $v \in \d{T_u}$, we can ''pad'' it with any symbol.
		We then have $\d{(P + q - u)} \subseteq \d{T_u}$.
		There are $O(n^2 / m^2)$ possible vectors $u$ and we run $\mathcal{A}$ for every pair of $T_u$ and $P$.
	\end{proof}
\end{theorem}



\subsection{Wildcard padding}
Consider the input strings for the two aforementioned two-dimensional problems -- an $n \times n$ text $T$ and $m \times m$ pattern $P$.
We construct one-dimensional strings $T'$ and $P'$ by ''flattening'' $T$ and $P$ with some extra padding characters.
Specifically:
\eq{
	T' &= T[0] \ \texttt{?}^{m} \ T[1] \ \texttt{?}^{m} \ \dots \ \texttt{?}^{m} \ T[n - 1] \ \texttt{?}^{m}, \\
	P' &= P[0] \ \texttt{?}^{n} \ P[1] \ \texttt{?}^{n} \ \dots \ \texttt{?}^{n} \ P[m - 1] \ \texttt{?}^{n}
}                                                                          
where $T[0], \dots, T[n - 1]$ and $P[0], \dots, P[m - 1]$ represent subsequent rows of $T$ and $P$ and \texttt{?} is the \textbf{wildcard} symbol that matches with every single character.

\begin{observation}\label{wildcard reduction}
	The Hamming distance between $T[i \dd i + m - 1, j \dd j + m - 1]$ and $P$ is equal to the Hamming distance between $T'[i(n + m) + j \dd (i + m)(n + m) + j - 1]$ and $P'$.
	As a result, any solution for \hd, which allows the text and pattern to contain wildcard symbols, can be easily generalized to solve \HD.
\end{observation}

Unfortunately, the most effective known algorithms for \hd rely on periodicity (\cite{Clifford2015}, \cite{Gawrychowski2017}) and do not allow wildcard symbols, thus, they cannot be easily generalized.
There are however two useful solutions for the \hd problem, which can.

\begin{fact}\label{sigman}
	There exists an algorithm which solves \hd in $\tO(n|\Sigma|)$ time.
	[maybe a reference?]
	It allows wildcard symbols in $T$ and $P$. 
\end{fact}

\begin{fact}\label{approx}
	There exists a $(1 + \varepsilon)$-approximate algorithm which solves \hd in $\tO(n)$ time.
	It was first introduced in \cite{Karloff1993}.
	It allows wildcard symbols in $T$ and $P$.
\end{fact}

\begin{corollary}
	By Observation \ref{wildcard reduction}. and Fact \ref{sigman}., there exists an algorithm which solves \HD in $\tO(n^2|\Sigma|)$ time.
\end{corollary}

\begin{corollary}
	By Observation \ref{wildcard reduction}. and Fact \ref{approx}., there exists a $(1 + \varepsilon)$-algorithm which solves \HD in $\tO(n^2)$ time.
\end{corollary}


\begin{theorem}
	Consider an $n \times n$ string $T$, $m \times m$ string $P$ and set of vectors $Q$ such that $\d{(P + q)} \subseteq \d{T}$ for every $q \in Q$.
	There exists an algorithm which calculates $ d_q = \Ham(P + q, T) $ for every $q \in Q$ in total time $\tO(n^2 + \sum_{q \in Q} d_q)$.
	\begin{proof}
		For the sake of clarity of this proof, we will temporarily switch to the classical array notation for strings.
		Let $T_0, \dots, T_{n - m}$ denote an array of two-dimensional strings (arrays) such that $T_k[0 \dd n - 1, 0 \dd m - 1] = T[0 \dd n - 1, k \dd k + m - 1]$.
		For every row of $P$ and every row of every $T_k$ we assign an integer identifier so that $\ID(P[i]) = \ID(T_k[j]) \Leftrightarrow P[i] = T_k[j]$ using KMR ([reference]) in $\tO(n^2)$.
		
		We use the approach described in [kangaroo reference].
		There exists a data structure (suffix array) which for a given one-dimensional array $S$ allows us to detect all mismatches between any given two of its subarrays of equal length.
		It can be built in $\tO(|S|)$ and the query time is $\tO(d)$ where $d$ is the number of mismatches.
		We construct the suffix array for the concatenation of the following arrays:
		\begin{itemize}
			\item the rows $P[i]$ for every $i$,
			\item the rows $T[i]$ for every $i$,
			\item the array $\ID(P[0]) \ID(P[1]) \dots \ID(P[m - 1])$,
			\item the arrays $\ID(T_k[0]) \ID(T_k[1]) \dots \ID(T_k[n - 1])$ for every $k$,
		\end{itemize}
		the total length of which is $\O(n^2)$.
		Let us consider a problem of detecting mismatches between $P$ and some $T' = T[j \dd j + m - 1, k \dd k + m - 1]$.
		We can firstly detect all such $i$ for which $P[i] \neq T'[i]$ by querying the subarrays $\ID(P[0]) \dots \ID(P[m - 1])$ and $\ID(T_k[j]) \dots \ID(T_k[j + m - 1])$.
		For every such $P[i] \neq T'[i]$ we can then find all mismatches by querying $P[i]$ and $T[i + j][k \dd k + m - 1]$.
	\end{proof}
\end{theorem}



% MAIN ALGORITHM
\section{Proof of Theorem \ref{main result}.}
Firstly, we run a two-dimensional variant of Karloff's $(1 + \varepsilon)$-algorithm with $\varepsilon = 1$ matching the pattern with the text.
We find the set $Q$ of vectors $q$ for which the estimated value of $\Ham(P + q, T)$ is at most $2k$.
We return $\infty$ for $q \not \in Q$ and to calculate the exact result for $q \in Q$ we distinguish two cases depending on the size of $Q$.


\subsection{Solution for few queries}
Assume that $|Q| \le 2n + n^2/k$.
For every $q \in Q$ we explicitly detect all mismatches using the ''kangaroo jumps'' technique in $\O(k)$ operations.
In total, the algorithm takes $\tO(n^2 + nk)$ time.


\subsection{Solution for many queries}
Assume that $|Q| > 2n + n^2/k$.
We take advantage of the fact that some occurrences of the pattern in the text must have a large overlap, and thus the pattern must be periodic.
Consequently, it can be decomposed into some regularly structured monochromatic substrings.
We employ a similar decomposition approach for the text and then calculate the result by summing the contributions of every pair of pattern and text substrings.

We start by defining two-dimensional periodicity and finding suitable periods of the pattern.


\begin{definition}[Periodicity]
	Consider any vector $\delta \in \Z^2$.
	We say that a string $S$ has an $\ell$-period $\delta$ if $$ \Ham(S + \delta, S) \le \ell. $$
\end{definition}


\begin{lemma} \label{periodicity_lemma}
	For every $u, v \in Q$, a vector $u - v$ is an $8k$-period of $P$.
\end{lemma}



\begin{theorem}
	\label{get_periods}
	For an integer $\ell > 0$ and a set of vectors $U \subseteq \set{0, \dots, \ell}^2 $ such that $|U| > 4\ell$ there exist $s, t, s', t' \in U$ such that $w = t - s$ and $w' = t' - s'$ hold the following conditions:
	\begin{itemize}
		\item $w, w' \neq \vec{0}$,
		\item $|w||w'| \le 22\frac{\ell^2}{|U|}$,
		\item $|\sin \alpha| \ge \frac{1}{2}$ where $\alpha$ is the angle between $w$ and $w'$,
		\item $w, w', -w, -w'$ are all contained in different quadrants.
	\end{itemize}
	There exists an algorithm which finds such $w, w'$ in $\tO(|U|)$ operations.
\end{theorem}


By running Algorithm \ref{get_periods}. on the set $Q$ we obtain vectors $\phi \in \Q_4$ and $\psi \in \Q_1$ which by Lemma \ref{periodicity_lemma}. are $\O(k)$-periods of $P$.
We use them as constants throughout the rest of the description along with $m = \phi \times \psi$.
Note that because $|Q| > n + n^2 / k$, we have $m \le |\phi||\psi| = \O(\min\set{n, k})$.

We will abuse the notation and for $u \in \Z^2$ write $\phi(u), \psi(u)$ to denote values $\phi \times u$ and $\psi \times u$.


\renewcommand{\L}{\mathcal{L}}
\begin{definition}[Lattice function]
	We call $\mathcal{F} : \Z^2 \to \set{1, \dots, m}$ a lattice function if
	$$ \mathcal{F}(u) = \mathcal{F}(v) \Longleftrightarrow \exists_{s, t \in \Z} \ u = v + s\phi + t\psi. $$
\end{definition}
\begin{lemma}
	There exists a lattice function (note that the values are from $1$ to $m$).
\end{lemma}


We choose any lattice function $\L$ and use it consistently throughout the description, as a way to help with the notation.
We will now show how to decompose the pattern and the text and how to calculate the result with the help of some auxiliary algorithms.


\begin{definition}[Parquet]
	Consider a set $U \subseteq \Z^2$. We call $U$ a \textbf{parquet} if there exist some values (restrictions) $x_0, x_1, y_0, y_1, \phi_0, \phi_1, \psi_0, \psi_1 \in \Z$ such that
	$$ U = \set{u : u \in \Z^2, x_0 < x(u) \le x_1, y_0 < y(u) \le y_1, \phi_0 < \phi(u) \le \phi_1, \psi_0 < \psi(u) \le \psi_1}. $$
	If some existing restrictions hold additional conditions, we classify $U$ as a special case of parquet:
	\begin{enumerate}[a)]
		\item if $x_1 - x_0 \ge |x(\phi)| + |x(\psi)|$ and $y_1 - y_0 \ge |y(\phi)| + |y(\psi)|$, then we call $U$ a \textbf{spacious} parquet,
		\item if $x_0, y_0 = -\infty$ and $x_1, y_1 = +\infty$, then we call $U$ a \textbf{simple} parquet,
		\item if $x_0, y_0, \phi_0, \psi_0 = -\infty$ and $x_1, y_1 = +\infty$, then we call $U$ a \textbf{primitive} parquet.
	\end{enumerate}
	Note that every primitive parquet is simple and every simple parquet is spacious.
\end{definition}


\begin{definition}[Subparquet]
	Consider a set $V \subseteq \Z^2$. 
	We call $V$ a \textbf{subparquet} if there exist a parquet $U$ and a value $\gamma \in \set{1, \dots, m}$ such that
	$$ V = \set{u : u \in U, \L(u) = \gamma}.$$
	We call $V$ a spacious/simple/primitive subparquet when there exists $U$ which is (correspondingly) a spacious/simple/primitive parquet.
	We will abuse the notation and for non-empty $V$ write $\L(V)$ to (unambiguously) denote the value $\gamma$. 
\end{definition}


\begin{definition}[Parquet string]
	For a string $S$, if $\d{S}$ is a spacious/simple (sub-)parquet, then we call $S$ a spacious/simple (sub-)parquet string.
	Note that since primitive (sub-)parquets are infinite, we do not extend their notion to strings.
\end{definition}


\newcommand{\Ta}{T_a}
\newcommand{\Tb}{T_b}
\begin{definition}[Active text]
	Consider a set $U = \bigcup_{q \in Q} \d{P} + q$. 
	We define substrings $\Ta = (U, \f{T})$ and $\Tb = (\d{T} \setminus U, \f{T})$.
	We will call $\Ta$ the \textbf{active text} and $\Tb$ the \textbf{inactive text}.
	For every $u \in \Z^2$ we define its \textbf{border distance} as
	$$\min\set{\|u - v\|_\infty : v \in (\Z^2 \setminus U)}.$$
\end{definition}


\begin{lemma}
	For every $q \in Q$ we have
	$$ \Ham(P + q, T) = \Ham(P + q, \Ta).$$
\end{lemma}


\begin{theorem}[Periodic parquet decomposition]
	\label{parquet_decomposition}
	Consider a spacious/simple parquet string $R$ with $\O(k)$-periods $\phi$ and $\psi$.
	It can be partitioned into $\O(k)$ monochromatic spacious/simple subparquet substrings, correspondingly.
	There exists an algorithm which finds those partitionings in $\tO(|\d{R}|)$ operations.
\end{theorem}


\newcommand{\T}{\mathcal{T}}
\renewcommand{\S}{\mathcal{S}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\F}{\mathcal{F}}

\begin{theorem}[Active text decomposition]
	\label{text_decomposition}
	There exists an algorithm which for any $\ell = \O(n)$ partitions $\Ta$ into a set of monochromatic simple subparquet substrings $\U$ and a substring $F$,
	such that $|\U| = \O(\min\set{n^2, \ell k})$ and for every $u \in F$ its border distance is $\O(n / \ell)$.
	It does so in $\tO(n^2)$ operations.
\end{theorem}


\begin{theorem}[Sparse Hamming]
	\label{sparse_algo}
	There exists an algorithm which for a set of monochromatic simple subparquet strings $\U$ and a set of monochromatic subparquet strings $\V$ calculates 
	$$ \sum_{U \in \U}\sum_{V \in \V} \Ham(U + q, V) $$
	for any $q \in \Z^2 $ in $\tO(1)$ operations after $\tO(\ell^2 + |\U||\V|)$ preprocessing time assuming that all strings are defined for vectors with coordinate values from $\set{0, \dots, \ell}$.
\end{theorem}


\begin{theorem}[Dense Hamming]
	\label{dense_algo}
	Consider a substring $F$ of $\Ta$ such that for every $u \in F$ its border distance is less than $\ell$ for some integer $\ell$.
	There exists an algorithm which calculates $\Ham(P + q, F)$ for every $q \in Q$ in total time $\tO(n^2 + n \ell k^{1/2})$.
\end{theorem}


As $P$ is a spacious parquet string, we partition it using Algorithm \ref{parquet_decomposition}. into a set of subparquet substrings $\V$.
Subsequently we partition $\Ta$ using Algorithm \ref{text_decomposition}. with $\ell = nk^{-3/4}$ into a set of simple subparquet substrings $\U$ and a substring $F$.
For every $q \in Q$ we then have
$$ \Ham(P + q, T) = \Ham(P + q, \Ta) = \Ham(P + q, F) + \sum_{U \in \U}\sum_{V \in \V} \Ham(U - q, V) $$
which we calculate by summing the results of Algorithm \ref{dense_algo} and Algorithm \ref{sparse_algo}


\section{Description of Algorithm \ref{get_periods}.}
Firstly, we find any closest pair of vectors $s, t \in U$ by running the standard $\tO(|U|)$ time algorithm and denote $w = t - s$.
We define a partial order $\le_{w}$ where $v \le_w u$ for some $u, v \in U$ when at least one condition holds:
\begin{enumerate}[(a)]
	\item $u = v$,
	\item $u - v$ and $w$ belong to the same quadrant,
	\item $\alpha \in (-\frac{\pi}{6}, \frac{\pi}{6})$ where $\alpha$ is the angle between $w$ and $u - v$.
\end{enumerate}
We find the longest chain $C$ and the longest antichain $A$ using dynamic programming in $\tO(|U|)$ operations.
We then find any closest pair of vectors $s', t' \in A$ and denote $w' = t' - s'$.
We have the following inequalities:
\begin{enumerate}[(i)]
	\item $|U| \le |C| |A|$ (by Dilworth's theorem),
	\item $(|C| - 1) |w| \le (1 + \sqrt{3})\ell$ (roughly by the fact that vectors in $C$ must be increasing in a certain direction), 
	\item $(|A| - 1) |w'| \le 2 \ell$ (by using a similar argument for vectors in $A$).
\end{enumerate}
By considering the assumpion $|U| > 4\ell$ it can be proven that $|w||w'| \le 22 \frac{\ell^2}{|U|}$ and the other conditions also hold.


\section{Description of Algorithm \ref{parquet_decomposition}.}
\begin{definition}[Lattice graph]
	For a set $U \subseteq \Z^2$ we define its \textbf{lattice graph} $G_U = (U, E_U)$ where
	$$ E_U = \bigset{\set{u, u + \delta} : \delta \in \set{\phi, \psi}, u \in U, u + \delta \in U} $$ 
	so every vector is connected with its translations by $\phi, \psi, -\phi, -\psi$.
\end{definition}
\begin{lemma}
	If $U$ is a spacious subparquet, then $G_U$ is connected.
\end{lemma}
Firstly, we partition $R$ into a set of subparquet substrings $\S$.
For every non-empty $S \in \S$ we consider a lattice graph $G_{\d{S}}$. If $S$ is not monochromatic, then since $G_{\d{S}}$ is connected, there must exist a pair of neighbouring vectors $v, w$ such that $S(v) \neq S(w)$.
We select any such pair and partition $S$ into spacious (or simple if $S$ is simple) subparquet substrings $S'$ and $S''$ such that $v \in S'$ and $w \in S''$.
For example if $v = w + \phi$, then $S' = \set{u : u \in S, \psi(u) \le \psi(v)}$ and $S'' = \set{u : u \in S, \psi(u) > \psi(v)}$.
In the cases when $v = w + \delta$ for $\delta \in \set{-\phi, \psi, -\psi}$ the construction in similar.

We can recursively partition $S'$ and $S''$ further until we obtain monochromatic substrings.
Because $R$ has $\O(k)$-periods $\phi$ and $\psi$, the total number of neighbor pairs $v, w$ such that $S(v) \neq S(w)$ is $\O(k)$ throughout all $S \in \S$.
Thus the total number of recursive calls is $\O(k)$ and because $|\S| = \O(k)$, the total number of constructed substrings is $\O(k)$.
The algorithm can be implemented to work in time $\tO(|\d{R}|)$.


\section{Description of Algorithm \ref{text_decomposition}.}

We assume $\ell$ to be an even number smaller than $\frac{n}{4}$. 
We start by partitioning $\d{T}$ into \textbf{tiles}.
We define $\phi_{\min} = \min \set{\phi(u) : u \in \d{T}}$, analogously $\phi_{\max}, \psi_{\min}, \psi_{\max}$ and denote $\delta_{\phi} = \frac{\phi_{\max} - \phi_{\min}}{\ell}$, $\delta_{\psi} = \frac{\psi_{\max} - \psi_{\min}}{\ell}$.
We define a tile with integer coordinates $(s, t)$ as a set of vectors $u \in \Z^2$ such that
$$ \phi_{\min} + s \delta_{\phi} < \phi(u) \le \phi_{\min} + (s + 1)\delta_{\phi}, $$ 
$$ \psi_{\min} + t \delta_{\psi} < \psi(u) \le \psi_{\min} + (t + 1)\delta_{\psi}. $$
For a fixed tile $U$, let's consider $x_{\min} = \min \set{x(u) : u \in U}$, analogously $x_{\max}, y_{\min}, y_{\max}$ and a set
$$ R = \set{u : u \in \Z^2, x_{\min} \le x(u) \le x_{\max}, y_{\min} \le y(u) \le y_{\max}}. $$
We classify $U$ into one of three types:
\begin{enumerate}[a)]
	\item if $U \cap \Ta = \emptyset$ then $U$ is an inactive tile,
	\item if $U \cap \Ta \neq \emptyset$, $R \not \subseteq \Ta$ then $U$ a border tile,
	\item if $U \cap \Ta \neq \emptyset$, $R \subseteq \Ta$ then $U$ is an active tile.
\end{enumerate}
We define $B$ as a set of all $u \in \Ta$ contained in a border tile and construct $F = (B, \f{T})$.
Let us denote $z = \frac{3n - 2}{4}$.
Consider a family of sets $\mathcal{R} = \set{R^1_i} \cup \set{R^2_i} \cup \set{R^3_i} \cup \set{R^4_i}$,
where for every active tile $U$ with coordinates $(s, t)$ its members are placed into exactly one subset:
\begin{enumerate}[1)]
	\item $R^1_{t}$ if $y_{\min} > z$, $x_{\max} \ge z$,
	\item $R^2_{s}$ if $x_{\max} < z$, $y_{\max} \ge z$,
	\item $R^3_{t}$ if $y_{\max} < z$, $x_{\min} \le z$,
	\item $R^4_{s}$ if $x_{\min} > z$, $y_{\min} \le z$.
\end{enumerate}
The number of non-empty sets $R \in \mathcal{R}$ is $\O(\ell)$.
For each of them we consider $S = (R, \f{T})$ which is a simple parquet string with $\O(k)$-periods $\phi$ and $\psi$,
and we further partition it using Algorithm \ref{parquet_decomposition}., thus constructing the set $\U$.


\section{Description of Algorithm \ref{sparse_algo}.}


For $U \in \U$, $V \in \V$, the value $ \Ham(U + q, V)$ either equals $|(\d{U} + q) \cap \d{V}|$ if $U[\d{U}] \neq V[\d{V}]$ or $0$ otherwise.
We have
$$ \sum_{U \in \U} \sum_{V \in \V} \Ham(U + q, V) = \sum_{(A, B) \in \F} |(A + q) \cap B| $$
where $ \F = \set{(\d{U}, \d{V}) : U \in \U, V \in \V, U[\d{U}] \neq V[\d{V}]} $. 
For every $(A, B) \in \F$ we can find primitive subparquets $A_1, \dots, A_4$ such that for every $q$ we have
$$ |(A + q) \cap B| = |(A_1 + q) \cap B| - |(A_2 + q) \cap B| - |(A_3 + q) \cap B| + |(A_4 + q) \cap B| $$
thus we will consider four instances of a problem of calculating $\sum_{(A, B) \in \F'} |(A + q) \cap B|$ where $A$ is a primitive subparquet and $B$ is a subparquet for all $(A, B) \in \F'$.

We will write $u \le_{\phi\psi} v$ to denote that $\phi(u) \le \phi(v) \wedge \psi(u) \le \psi(v)$ for some $u, v \in \Z^2$.


\begin{theorem}
	\label{sweeper}
	There exists a data structure which for a given set of vectors $U$ and a set of parquets $\S$ calculates
	$$ \sum_{v \in V} |\set{S : S \in \S, v \in S}| $$
	for a given query vector $q$ where $V = \set{v : v \in U, v \le_{\phi\psi} q}$.
	It requires $\tO(|U| + |\S|)$ preprocessing time and $\tO(1)$ query time.
\end{theorem}


We consider an array of data structures $J_1, \dots, J_m$ described in Algorithm \ref{sweeper}.
We construct $J_\gamma$ for a set of points $U_\gamma = \set{u : u \in \Z^2, |x(u)| \le \ell, |y(u)| \le \ell, \L(u) = \gamma}$ and set of parquets $\S_\gamma$.
To construct $\S_\gamma$ we consider every pair $(A, B) \in \F'$ and find a vector $w$ and a parquet $V$ such that 
$$ A = \set{u : u \le_{\phi\psi} w, \L(u) = \L(w)},$$
$$ B = \set{u : u \in (V + w), \L(u) = \L(B)}.$$
The set $\S_\gamma$ contains the parquets $V$ obtained for pairs $(A, B)$ such that $\L(B - w) = \gamma$.
We can obtain the result of $\sum_{(A, B) \in \F'} |(A + q) \cap B|$ by making a query to $J_{\L(q)}$ with vector $q$.

For explanation, if $\L(A + q) \neq \L(B)$, then $(A + q) \cap B = \emptyset$.
Otherwise $\L(q) = \L(B - w) = \gamma$ and we have
$$ (A + q) \cap B = \set{u : u \le_{\phi\psi} w + q, u \in (V + w), \L(u) = \L(B)} = \set{v : v \le_{\phi\psi} q, v \in V, \L(v) = \gamma} $$


\section{Description of Algorithm \ref{dense_algo}.}
To be done.
%	We assume $l$ to be less than $\frac{1}{2}n$.
%	We first partition the string $F$ into four substrings:
%	\begin{itemize}
%		\item $F_1 = (\set{0, \dots, \frac{3}{4}n - 1} \times \set{0, \dots, \frac{3}{4}n - 1} \cap \d{F}, \f{F})$
%		\item $F_2 = (\set{0, \dots, \frac{3}{4}n - 1} \times \set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \cap \d{F}, \f{F})$
%		\item $F_3 = (\set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \times \set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \cap \d{F}, \f{F})$
%		\item $F_4 = (\set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \times \set{0, \dots, \frac{3}{4}n - 1} \cap \d{F}, \f{F})$
%	\end{itemize}
%	We then independently calculate $\Ham(P + q, F_i)$ for each $i$ and sum the results.
%	
%	To calculate the solution for $\Ham(P + q, F_1)$, let's consider substrings of $P$:
%	$$ P_1 = (\set{0, \dots, l - 1} \times \set{0, \dots, n - 1}, \f{P}) $$
%	$$ P_2 = (\set{l, \dots, n - 1} \times \set{0, \dots, l - 1}, \f{P}) $$
%	\begin{lemma}
%		For $q \in Q$ we have
%		$$ \Ham(P + q, F_1) = \Ham(P_1 + q, F_1) + \Ham(P_2 + q, F_2) $$
%	\end{lemma}
%	To calculate $\Ham(P_1 + q, F_1)$ let's partition $F_1$ into substrings $\S = \set{S_i}$, where
%	$$ S_i = ((il + \set{0, \dots, l - 1}) \times \Z \cap \d{F_1}, \f{F_1}) $$
%	For every non-empty string $S_i$ let's define $h_i = \max\set{y(u) : u \in S_i} - \min\set{y(u) : u \in S_i}$.
%	\begin{lemma}
%		For every $S_i$ we have
%		$$ \Ham(P_1 + q, S_i) = \Ham(B_i + q, S_i) $$
%		where $B_i = (\Z \times \set{0, \dots, h_i} \cap \d{P_1}, \f{P_1}) $ for non-empty $S_i$, otherwise $B_i$ is empty.
%	\end{lemma}
%	\begin{lemma}
%		The sum of $h_i$ for non-empty sets $S_i$ is $\O(n)$.
%	\end{lemma}
%	\begin{theorem}
%		\label{2dfft}
%		Consider two parquet strings $U$, $V$ such that
%		$$ \max\set{x(u) - x(v) : u, v \in U}, \max\set{x(u) - x(v) : u, v \in V} \le \delta_x $$
%		$$ \max\set{y(u) - y(v) : u, v \in U}, \max\set{y(u) - y(v) : u, v \in V} \le \delta_y $$
%		for some $\delta_x, \delta_y$
%		[TODO what the other conditions have to be, but it's clearly possible for our case].
%		There exists an algorithm which calculates $\Ham(U + q, V)$ for every $q \in \Z^2$ for which it is non-zero (maybe less than $k$).
%		There are $O(\delta_x\delta_y)$ such vectors $q$ and the algorithm takes $\tO(\delta_x\delta_yk^{1/2})$ time.
%	\end{theorem}
%	We have 
%	$$ \Ham(P_1 + q, F_1) = \sum_i \Ham(B_i + q, S_i) $$
%	By using Algorithm \ref{2dfft}. for every non-empty pair $B_i, S_i$, we obtain the total complexity $\tO(nlk^{1/2})$.
%	
%	For $\Ham(P_2 + q, F_1)$ we use the same approach, as well as in the case of $\Ham(P + q, F_2)$, etc.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
