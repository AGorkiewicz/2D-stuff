\documentclass[11pt]{article}
\pdfoutput=1
\usepackage[margin=1in,a4paper]{geometry}
\usepackage{amsthm,amssymb,amsmath}  
\usepackage{xspace,enumerate}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks=true,urlcolor=Blue,citecolor=Green,linkcolor=BrickRed]{hyperref}
\usepackage[capitalise]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{authblk}


\def\dd{\mathinner{.\,.}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\tO}{\tilde{\mathcal{O}}}
\renewcommand{\phi}{\varphi}
\newcommand{\set}[1]{\left\lbrace #1 \right\rbrace}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\bigset}[1]{\big \lbrace #1 \big \rbrace}
\newcommand{\Bigset}[1]{\Big \lbrace #1 \Big \rbrace}
\newcommand{\eq}[1]{\begin{align*} #1 \end{align*}}
\newcommand{\defproblem}[3]{\begin{center}\vspace{2mm}\noindent\fbox{\begin{minipage}{0.96\textwidth} #1 \\ {\bf{INPUT:}} #2 \\ {\bf{OUTPUT:}} #3 \end{minipage}} \vspace{2mm}\end{center}}


\usepackage{microtype} %if unwanted, comment out or use option "draft"
\usepackage{amsmath,amsfonts}
\usepackage[cmbtt]{bold-extra}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{thm-restate}
\usepackage{comment}
\usepackage{forest}
\usepackage{xspace}
\usepackage{enumerate}
\usepackage{makecell}
\usepackage{listings}
\usepackage{multirow}
\usepackage{diagbox}
\usepackage{todonotes}
\usepackage{thmtools}
\usepackage[ruled,noline,noend]{algorithm2e}
\usepackage[capitalise]{cleveref}
\usepackage{graphics,adjustbox}
\usepackage{tabularx}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{verbatim}
\usepackage{braket}
\usepackage[noadjust]{cite}
\usepackage{xspace}
\usepackage{bold-extra}
\usepackage[margin=1in]{geometry}

\pagestyle{myheadings}


\title{Fast algorithm for two-dimensional pattern matching with $k$ mismatches}
\author[1]{Jonas Ellert}
\author[2]{Paweł Gawrychowski}
\author[3]{Adam Górkiewicz}
\author[4]{Tatiana Starikovskaya}
\affil[1]{?}
\affil[2]{?}
\affil[3]{?}
\affil[4]{?}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}  
\newtheorem{fact}{Fact}
\newtheorem{corollary}[fact]{Corollary}  
\newtheorem{observation}{Observation}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture} 
\newtheorem*{claim}{Claim}
\newtheorem{problem}{Problem}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}


\sloppy

\DeclareMathOperator*{\xspan}{x-span}
\DeclareMathOperator*{\yspan}{y-span}
\DeclareMathOperator*{\score}{score}
\DeclareMathOperator*{\Ham}{Ham}
\DeclareMathOperator*{\Fit}{Fit}
\DeclareMathOperator*{\ID}{Id}
\DeclareMathOperator*{\BD}{BD}
\DeclareMathOperator*{\dom}{dom}
\DeclareMathOperator*{\charrr}{C}
\newcommand{\restr}[2]{#1\restriction_{#2}}

% BEGIN DOCUMENT
\begin{document}

\date{}
\maketitle

\begin{abstract}
\end{abstract}

%\thispagestyle{empty}
%\clearpage
%\setcounter{page}{1}


% INTRODUCTION
\section{Introduction}

\newcommand{\hd}{\textsc{HD1D}\xspace}
\newcommand{\HD}{\textsc{HD2D}\xspace}

We consider the one-dimensional all-substring Hamming distance problem (\hd), where for a given text string $T$ of length $n$ and a string $P$ of length $m$ ($m < n$), we want to calculate the Hamming distance between $P$ and every fragment $T$ of length $m$.

We consider the two-dimensional all-substring Hamming distance problem (\HD), where for a given 2D string $T$ of size $n \times n$ and a string $P$ of size $m \times m$ ($m < n$), we want to calculate the Hamming distance between $P$ and every $m \times m$ fragment of $T$.

We also consider the bounded variants of \hd and \HD, where we are only required to calculate the distances which are not greater than $k$, for some parameter $k \in \Z^+$.


\begin{theorem}[Main result]\label{main result}
	Bounded \HD can be solved in $\tO((m^2 + mk^{5/4})n^2 / m^2)$ time.
\end{theorem}


% PRELIMINARIES
\section{Preliminaries}

For our purposes we will not use the standard definition of a two-dimensional string, where we associate it with a two-dimensional array of characters, and instead we will define it more broadly.
Although we will occasionally use the array notation, we will do it exclusively for $n \times m$ strings.
For any $n \in \Z^+$ we will denote $[n] = \set{0, \dots, n - 1}$.
We will only consider integer points or vectors and we will use these terms interchangeably.
For a function $f$ and a subset of its domain $X$ we will write $\restr{f}{X}$ to denote the restriction of $f$ to $X$.
Our results hold under word-RAM model of computation.

\newcommand{\getchar}[1]{\charrr(#1)}
\newcommand{\pto}{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
\renewcommand{\d}[1]{\dom(#1)}
\newcommand{\f}[1]{#1^\mathbf{f}}
\begin{definition}[Two-dimensional string]
	We define a \textbf{string} $S$ as a partial function $\Z^2 \pto \Sigma$ which maps some arbitrary set of integer points, denoted as $\d{S}$, to characters.
	For simplicity we will write $u \in S$ to denote that $u \in \d{S}$.
	We say that a string $S$ is \textbf{partitioned} into strings $R_1, \dots, R_\ell$ when the sets $\d{R_1}, \dots, \d{R_\ell}$ partition $\d{S}$ and $R_i(u) = S(u)$ for all $u \in R_i$.
	We call a string $S$ \textbf{monochromatic} when $S(u) = \sigma$ for every $u \in S$ for some $\sigma \in \Sigma$ and we will write $\getchar{S}$ to denote the value $\sigma$.
	We say that $S$ is $n \times m$ for some $n, m \in \Z^+$ when $\d{S} = [n] \times [m]$.
	Physically we represent a string as a list of point-character pairs.
\end{definition}


\begin{definition}[Shifting]
	For a set of points $V \subseteq \Z^2$ and a vector $u \in \Z^2$, we denote $V + u$ as $\set{v + u : v \in V}$.
	For a string $S$ and a vector $u \in \Z^2$ we denote $S + u$ as a string $R$ such that
	$\d{R} = \d{S} + u$ and $R(v) = S(v - u)$ for $v \in \d{R}$.
	Intuitively, we shift the set of points while maintaining their character values.
\end{definition}


\begin{definition}[Hamming distance]
	For a pair of strings $S, R$ we define
	$$ \Ham(S, R) = |\set{u : u \in \d{S} \cap \d{R}, S(u) \neq R(u)}|,$$
	which corresponds to the number of mismatches between $S$ and $R$.
\end{definition}


Under such notation, the \HD problem is equivalent to calculating the (bounded or unbounded) values of $ \Ham(P + q, T) $
for all $q \in \Z^2$ such that $\d{P + q} \subseteq \d{T}$ (so for $q \in [n - m]^2$).


\begin{definition}[Don't care symbol]
	We define the \textbf{don't care} symbol as a special character which matches with every character.
	We will denote it with \texttt{?}.
	Unless stated otherwise, we assume it is not allowed in $\Sigma$ and in both \hd and \HD every character present in $T$ and $P$ matches only with itself.
\end{definition}


\newcommand{\x}[1]{#1.x}
\newcommand{\y}[1]{#1.y}
\newcommand{\h}[1]{\phi \times #1}
\newcommand{\s}[1]{\psi \times #1}
\begin{definition}[Vector operators]
	For any $u \in \Z^2$ we refer to its coordinates as $\x{u}, \y{u}$.
	For $u, v \in \Z^2$ we denote $u \cdot v = \x{u} \cdot \x{v} + \y{u} \cdot \y{v}$
	and $u \times v = \x{u} \cdot \y{v} - \y{u} \cdot \x{v}$.
	Note that alternatively $u \cdot v = |u||v| \cos \alpha$ and $u \times v = |u||v| \sin \alpha$ where $\alpha$ is the angle between $u$ and $v$.
\end{definition}


\newcommand{\Q}{\mathcal{Q}}
\begin{definition}[Quadrants]
	We define the four \textbf{quadrants} as
	\eq{
		\Q_1 &= (0, +\infty) \times [0, +\infty), \\
		\Q_2 &= (-\infty, 0] \times (0, +\infty), \\
		\Q_3 &= (-\infty, 0) \times (-\infty, 0], \\
		\Q_4 &= [0, +\infty) \times (-\infty, 0).
	}
\end{definition}


\section{One-dimensional generalizations}
In this section we explore some of the methods used for one-dimensional strings.
Specifically, as our goal is to generalize the solution for pattern matching with $k$ mismatches described in \cite{Gawrychowski2017}, we are especially interested in two-dimensional variants of the techniques that were used to solve the one-dimensional case.


\begin{theorem}[Instancing]\label{instancing}
	Consider an algorithm $\mathcal{A}$ which solves \HD (bounded or unbounded), but only when $2|n$ and $n \le \frac{3}{2}m$.
	If its running time is $\mathcal{T}(m)$, then the general case can be solved in $\O(\mathcal{T}(m) n^2 / m^2)$.
	\begin{proof}
		Let $r = \floor{m / 2}$ and let $n' = r + m - 1$ or $r + m$ if $r + m - 1$ is odd.
		We see that the set $N = [n']^2$ satisfies the conditions for the text domain.
		For any vector $q \in [n - m]^2$ we can find a vector $u$ such that $r|u.x, r|u.y$ and $q - u \in [r]^2$,
		so we have $\Ham(P + q, T) = \Ham(P + q - u, T_u)$ where $T_u = \restr{(T - u)}{N}$.
		If $T - u$ is not defined for some $v \in N$, we can pad $T_u(v)$ with any character.
		We see that $\d{P + q - u} \subseteq N = \d{T_u}$.
		There are $\O(n^2 / m^2)$ possible vectors $u$ and we run $\mathcal{A}$ for every pair of $T_u$ and $P$.
	\end{proof}
\end{theorem}


\begin{theorem}[Kangaroo jumps]\label{kangaroos}
	Consider an $n \times n$ string $T$, $m \times m$ string $P$ and set of vectors $Q$ such that $\d{P + q} \subseteq \d{T}$ for every $q \in Q$.
	There exists an algorithm which calculates $ d_q = \Ham(P + q, T) $ for every $q \in Q$ in total time $\tO(n^2 + \sum_{q \in Q} d_q)$.
	\begin{proof}
		For the sake of clarity, we will temporarily switch to the classical array notation for strings.
		Let $T_0, \dots, T_{n - m}$ denote an array of two-dimensional strings (arrays) such that $T_k[0 \dd n - 1, 0 \dd m - 1] = T[0 \dd n - 1, k \dd k + m - 1]$.
		For every row $P[0], \dots, P[m - 1]$ of $P$ and every row $T_k[0], \dots, T_k[n - 1]$ of every $T_k$ we assign an integer identifier so that $\ID(P[i]) = \ID(T_k[j]) \Leftrightarrow P[i] = T_k[j]$ by using the KMR algorithm ([reference]) in $\tO(n^2)$.
		
		We use the approach described in [kangaroo reference].
		There exists a data structure (suffix array) which for a given one-dimensional array $S$ allows us to detect all mismatches between any given two of its subarrays of equal length.
		It can be built in $\tO(|S|)$ and the query time is $\tO(d + 1)$ where $d$ is the number of mismatches.
		We construct the suffix array for the concatenation of the following arrays:
		\begin{itemize}
			\item the rows $P[i]$ for every $i$,
			\item the rows $T[i]$ for every $i$,
			\item the array $\ID(P[0]) \ID(P[1]) \dots \ID(P[m - 1])$,
			\item the arrays $\ID(T_k[0]) \ID(T_k[1]) \dots \ID(T_k[n - 1])$ for every $k$,
		\end{itemize}
		the total length of which is $\O(n^2)$.
		Let us consider a problem of detecting mismatches between $P$ and some $T' = T[j \dd j + m - 1, k \dd k + m - 1]$.
		We can first find all row indices $i$ for which $P[i] \neq T'[i]$ by finding all mismatches between $\ID(P[0]) \dots \ID(P[m - 1])$ and $\ID(T_k[j]) \dots \ID(T_k[j + m - 1])$, which we do with query to the data structure.
		For every such $i$ we can then find all mismatches between $P[i]$ and $T'[i]$ by querying $P[i]$ and $T[i + j][k \dd k + m - 1]$.
		If the distance between $P$ and $T'$ is $d$, the first query takes $\tO(d + 1)$ operations and all subsequent queries take $\tO(d + 1)$ operations in total.
	\end{proof}
\end{theorem}


\begin{lemma}\label{sigman1d}
	$\hd$ with don't care symbols can be solved in $\tO(n|\Sigma|)$ by running $|\Sigma|$ instances of FFT.
\end{lemma}


\begin{lemma}\label{approx1d}
	There exists a $(1 + \varepsilon)$-approximate algorithm (introduced in \cite{Karloff1993}) which solves \hd with don't care symbols in $\tO(n)$.
\end{lemma}


\begin{theorem}\label{sigman2d}
	$\HD$ with don't care symbols can be solved in $\tO(n^2|\Sigma|)$.
	\begin{proof}
		We will again use the array notation.
		We construct one-dimensional strings $\bar{T}$ and $\bar{P}$ by concatenating subsequent rows $T[0], \dots, T[n - 1]$ of $T$ and rows $P[0], \dots, P[m - 1]$ of $P$ padded with don't care symbols:
		$$ \bar{T} = T[0] \ T[1] \ \dots \ T[n - 1], $$
		$$ \bar{P} = P[0] \ \texttt{?}^{n - m} \ P[1] \ \texttt{?}^{n - m} \ \dots \ \texttt{?}^{n - m} \ P[m - 1].$$
		We run the algorithm from \Cref{sigman1d}.
		The distance between $T[i \dd i + m - 1, j \dd j + m - 1]$ and $P$ is equal to the distance between $\bar{T}[in + j \dd in + j + nm - n + m - 1]$ and $\bar{P}$.
	\end{proof}
\end{theorem}


\begin{theorem}\label{approx2d}
	There exists a $(1 + \varepsilon)$-approximate algorithm which solves \HD with don't care symbols in $\tO(n^2)$.
	\begin{proof}
		Identical to \Cref{sigman2d}, but we use the algorithm from \Cref{approx1d} instead of \Cref{sigman1d}.
	\end{proof}
\end{theorem}


The same reduction as in \Cref{sigman2d} can be applied for every \hd solution which allows don't care symbols.
Unfortunately, the most effective known algorithms for bounded \hd rely on periodicity (\cite{Clifford2015}, \cite{Gawrychowski2017}) and inherently do not allow don't care symbols, thus, they cannot be easily generalized.


\begin{observation}[Don't care padding]
	Every \HD solution which allows don't care symbols (eg. the algorithms from \Cref{sigman2d} and \Cref{approx2d}) can be extended to also calculate the Hamming distance for occurrences of $P$ which are not entirely contained in $T$.
	It can be done by padding the text with don't care symbols and it does not change the complexity of the solution.
\end{observation}


% MAIN ALGORITHM
\section{Proof of Theorem \Cref{main result}}
We show an algorithm which works in time $\tO(m^2 + mk^{5/4})$ assuming $2|n$ and $m < n \le \frac{3}{2}m$.
By \Cref{instancing}, our main result follows.

We start by running the algorithm from \Cref{approx2d} with $\varepsilon = 1$.
We construct the set $Q$ as the set of such vectors $q \in \Z^2$ for which the estimated value of $\Ham(P + q, T)$ is at most $2k$.
For every $q \in \set{0, \dots, n - m}^2 \setminus Q$ we say that $\Ham(P + q, T)$ equals $\infty$.
The next step is to calculate the exact value of $\Ham(P + q, T)$ for every $q \in Q$.

Let us consider the case when $|Q| \le 2m + m^2/k$.
We can run the algorithm from \Cref{kangaroos} and by the fact that $\Ham(P + q, T) \le 4k$ for every $q \in Q$, it will perform $\tO(m^2 + mk)$ operations.
We are left with the case when $|Q| > 2m + m^2/k$, in which we take advantage of the fact that some strings $P + q$ for $q \in Q$ must have a large overlap and small Hamming distance from each other, and thus $P$ must be periodic.


\newcommand{\T}{\mathcal{T}}
\renewcommand{\S}{\mathcal{S}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\L}{\mathcal{L}}


% 2D PERIODICITY
\subsection{Two-dimensional periodicity}
In this section we introduce a range of new tools related to two-dimensional periodicity.
We then select some special periods of the pattern and show how to decompose it into some regularly structured monochromatic strings.


\begin{definition}[Periodicity]
	Consider any vector $\delta \in \Z^2$.
	We say that a string $S$ has an $\ell$-period $\delta$ when
	$$ \Ham(S + \delta, S) \le \ell. $$
\end{definition}


\begin{lemma} \label{periodicity_lemma}
	For every $u, v \in Q$, the vector $u - v$ is an $8k$-period of $P$.
	\begin{proof}
		$\Ham(P + u - v, P) = \Ham(P + u, P + v) \le \Ham(P + u, T) + \Ham(P + v, T) \le 4k + 4k. $
	\end{proof}
\end{lemma}


\begin{theorem} \label{get_periods}
	For a given $\ell \in \Z^+$ and a set of points $U \subseteq [\ell + 1]^2 $ such that $|U| > 4\ell$ there exist $s, t, s', t' \in U$ such that the following conditions hold for $w = t - s$ and $w' = t' - s'$:
	\begin{itemize}
		\item $0 < |w||w'| \le 22\frac{\ell^2}{|U|}$,
		\item $|\sin \alpha| \ge \frac{1}{2}$ where $\alpha$ is the angle between $w$ and $w'$,
		\item $w, w', -w, -w'$ are all contained in different quadrants.
	\end{itemize}
	Such $w, w'$ can be found in $\tO(|U|)$ operations.
\end{theorem}


We run the algorithm from \Cref{get_periods} on the set $Q$ (where $\ell = n - m \le m / 2$, thus $|Q| > 2m + m^2/k \ge 4\ell$).
We obtain vectors $\phi \in \Q_4$ and $\psi \in \Q_1$ which by \Cref{periodicity_lemma} are $\O(k)$-periods of $P$.
We will refer to those vectors throughout the rest of the description and we define $p = \phi \times \psi$.
Note that because $|Q| > 2m + m^2 / k$, we have $p \le |\phi||\psi| = \O(\min\set{m, k})$.


\begin{definition}[Lattice congruency]\label{lattice_congruency}
	We define $\L = \set{s\phi + t\psi : s, t \in \Z}$.
	We say that two vectors $u, v \in \Z^2$ are \textbf{lattice-congruent} and denote $u \equiv v$ when $u - v \in \L$ [Galil citation].
\end{definition}


\begin{lemma} \label{lattice_base}
	There exists a set of points $\Gamma \subseteq \Z^2$ such that $|\Gamma| = p$ and every point $u \in \Z^2$ is lattice-congruent to exactly one point $\gamma \in \Gamma$.
\end{lemma}


\begin{definition}[Parquet]
	We call a non-empty set $U \subseteq \Z^2$ a \textbf{parquet} when there exist some values $x_0, x_1, y_0, y_1, \phi_0, \phi_1, \psi_0, \psi_1 \in \Z$, which we will call its \textbf{signature}, such that
	$$ U = [x_0, x_1) \times [y_0, y_1) \cap \set{u : u \in \Z^2, \h{u} \in [\phi_0, \phi_1), \s{u} \in [\psi_0, \psi_1)}. $$
	\begin{enumerate}[a)]
		\item If additionally $x_1 - x_0 \ge |\x{\phi}| + |\x{\psi}|$ and $y_1 - y_0 \ge |\y{\phi}| + |\y{\psi}|$, then $U$ is a \textbf{spacious} parquet.
		\item If additionally $x_0, y_0 = -\infty$ and $x_1, y_1 = +\infty$, then $U$ is a \textbf{simple} parquet.
	\end{enumerate}
	Note that every simple parquet is spacious.
\end{definition}


\begin{definition}[Subparquet]
	We call a non-empty set $V \subseteq \Z^2$ a \textbf{subparquet} when there exists a parquet $U$ and a point $\gamma \in \Z^2$ such that
	$$ V = \set{u : u \in U, u \equiv \gamma}.$$
	We call $V$ a spacious/simple subparquet when there exists $U$ which is (correspondingly) a spacious/simple parquet.
	We say that $V$ is lattice-congruent to some $v \in \Z^2$ (denoted as $V \equiv v$) when $v \equiv \gamma$.
	We similarly define lattice congruency between two subparquets.
\end{definition}


\begin{definition}[Parquet string]
	We call a string $S$ a spacious/simple (sub-)parquet string when $\d{S}$ is a spacious/simple (sub-)parquet.
\end{definition}


\begin{theorem}[Periodic string decomposition]\label{parquet_decomposition}
	A given spacious/simple parquet string $R$ with $\O(k)$-periods $\phi$ and $\psi$ can be partitioned in time $\tO(|\d{R}|)$ into $\O(k)$ monochromatic spacious/simple subparquet strings, correspondingly.
\end{theorem}


Since $|\x{\phi}|, |\y{\phi}|, |\x{\psi}|, |\y{\psi}| \le n - m \le m / 2$, the $m \times m$ string $P$ is a spacious parquet string and satisfies the assumptions of \Cref{parquet_decomposition}.
We partition $P$ into a set of monochromatic spacious subparquet strings $\V$, where $|\V| = \O(k)$.
Note that because the text is not necessarily periodic, we unfortunately cannot use the same approach for $T$.


% TEXT DECOMPOSITION
\subsection{Text decomposition}
In this section we show how to decompose the text using a similar but more nuanced approach.
We then introduce an effective way to aggregate the contributions of every pair of strings that $P$ and $T$ are decomposed into.


\newcommand{\Ta}{T_\mathbf{a}}
\newcommand{\Tb}{T_\mathbf{b}}
\begin{definition}[Active text]
	Let $A = \bigcup_{q \in Q} \d{P} + q$ and $B = \d{T} \setminus A$. 
	We define the \textbf{active text} as a string $\Ta = \restr{T}{A}$ and the \textbf{inactive text} as a string $\Tb = \restr{T}{B}$.
	For a point $u \in \Z^2$ we define its \textbf{border distance} as
	$\min\set{\|u - v\|_\infty : v \in B} $,
	which we will denote as $\BD(u)$.
	For a set of points $U \subseteq \Z^2$ we define $\BD(U) = \max\set{\BD(u) : u \in U}$.
	Note that we consider the maximum distance, not minimum.
\end{definition}


\begin{observation}
	$\Ham(P + q, T) = \Ham(P + q, \Ta)$ for every $q \in Q$.
\end{observation}


\begin{theorem}[Active text decomposition]\label{text_decomposition}
	For a given parameter $\ell \in ?$ the active text can be partitioned in time $\tO(m^2)$ into a set of $\O(\min\set{m^2, \ell k})$ monochromatic simple subparquet strings
	and a string $F$ such that $\BD(F) = \O(m / \ell)$.
\end{theorem}


\begin{theorem}\label{sparse_algo}
	For a given list of signatures of simple subparquets $U_1, \dots, U_\ell$, list of signatures of subparquets $V_1, \dots, V_\ell$ and a set of vectors $Q$ we can calculate
	$$ \sum_{i = 1}^\ell |(U_i + q) \cap V_i| $$
	for every $q \in Q$ in total time $\tO(n^2 + \ell + |Q|)$ assuming that the subparquets only contain vectors of length $\O(n)$.
\end{theorem}


\begin{theorem}\label{dense_algo}
	For a given string $F$ such that $\d{F} \subseteq \d{\Ta}$ we can calculate $\Ham(P + q, F)$ for every $q \in Q$ in total time $\tO(m^2 + m k^{1/2} \BD(F) )$.
\end{theorem}


We partition $\Ta$ using the algorithm from \Cref{text_decomposition} with $\ell = mk^{-3/4}$ into a set of simple subparquet strings $\U$ and a string $F$.
For every $q \in Q$ we then have
$$ \Ham(P + q, \Ta) = \Ham(P + q, F) + \sum_{U \in \U}\sum_{V \in \V} \Ham(U - q, V) $$
% which we calculate by summing the results of algorithms from \Cref{dense_algo} and \Cref{sparse_algo}.


% PHI PSI FINDER
\subsection{Proof of \Cref{get_periods}}
First, we find any closest pair of vectors $s, t \in U$ by running the standard $\tO(|U|)$ time algorithm and denote $w = t - s$.
We define a partial order $\le_{w}$ where $v \le_w u$ for some $u, v \in U$ when at least one condition holds:
\begin{enumerate}[(a)]
	\item $u = v$,
	\item $u - v$ and $w$ belong to the same quadrant,
	\item $\alpha \in (-\frac{\pi}{6}, \frac{\pi}{6})$ where $\alpha$ is the angle between $w$ and $u - v$.
\end{enumerate}
We find the longest chain $C$ and the longest antichain $A$ using dynamic programming in $\tO(|U|)$ operations.
We then find any closest pair of vectors $s', t' \in A$ and denote $w' = t' - s'$.
We have the following inequalities:
\begin{enumerate}[(i)]
	\item $|U| \le |C| |A|$ (by Dilworth's theorem),
	\item $(|C| - 1) |w| \le (1 + \sqrt{3})\ell$ (roughly by the fact that vectors in $C$ must be increasing in a certain direction), 
	\item $(|A| - 1) |w'| \le 2 \ell$ (by using a similar argument for vectors in $A$).
\end{enumerate}
By considering the assumption $|U| > 4\ell$ it can be proven that $|w||w'| \le 22 \frac{\ell^2}{|U|}$ and the other conditions also hold.


% PARQUET DECOMPOSITION
\subsection{Proof of \Cref{parquet_decomposition}}


\begin{definition}[Lattice graph]
	For a set $U \subseteq \Z^2$ we define its \textbf{lattice graph} $G_U = (U, E_U)$ where
	$$ E_U = \bigset{\set{u, u + \delta} : \delta \in \set{\phi, \psi}, u \in U, u + \delta \in U} $$ 
	so every vector is connected with its translations by $\phi, \psi, -\phi, -\psi$.
\end{definition}


\begin{lemma}
	If $U$ is a spacious subparquet, then $G_U$ is connected.
\end{lemma}


Firstly, we partition $R$ into a set of subparquet strings $\S$.
For every non-empty $S \in \S$ we consider a lattice graph $G_{\d{S}}$. If $S$ is not monochromatic, then since $G_{\d{S}}$ is connected, there must exist a pair of neighboring vectors $v, w$ such that $S(v) \neq S(w)$.
We select any such pair and partition $S$ into spacious (or simple if $S$ is simple) subparquet strings $S'$ and $S''$ such that $v \in S'$ and $w \in S''$.
For example if $v = w + \phi$, then $S' = \set{u : u \in S, \s{u} \le \s{v}}$ and $S'' = \set{u : u \in S, \s{u} > \s{v}}$.
In the cases when $v = w + \delta$ for $\delta \in \set{-\phi, \psi, -\psi}$ the construction in similar.

We can recursively partition $S'$ and $S''$ further until we obtain monochromatic strings.
Because $R$ has $\O(k)$-periods $\phi$ and $\psi$, the total number of neighbor pairs $v, w$ such that $S(v) \neq S(w)$ is $\O(k)$ throughout all $S \in \S$.
Thus the total number of recursive calls is $\O(k)$ and because $|\S| = \O(k)$, the total number of constructed strings is $\O(k)$.
The algorithm can be implemented to work in time $\tO(|\d{R}|)$.


% TEXT DECOMPOSITION
\subsection{Proof of \Cref{text_decomposition}}


We assume $\ell$ to be an even number smaller than $\frac{n}{4}$ (if it is not, we can find $\ell' = \Theta(\ell)$, which is). 
We start by partitioning $\d{T}$ into \textbf{tiles}.
We define $\phi_{\min} = \min \set{\h{u} : u \in \d{T}}$, analogously $\phi_{\max}, \psi_{\min}, \psi_{\max}$ and denote $\delta_{\phi} = \frac{\phi_{\max} - \phi_{\min}}{\ell}$, $\delta_{\psi} = \frac{\psi_{\max} - \psi_{\min}}{\ell}$.
We define a tile with integer coordinates $(s, t)$ as a set of vectors $u \in \Z^2$ such that
$$ \phi_{\min} + s \delta_{\phi} < \h{u} \le \phi_{\min} + (s + 1)\delta_{\phi}, $$ 
$$ \psi_{\min} + t \delta_{\psi} < \s{u} \le \psi_{\min} + (t + 1)\delta_{\psi}. $$
For a fixed tile $U$ consider $x_{\min} = \min \set{\x{u} : u \in U}$, analogously $x_{\max}, y_{\min}, y_{\max}$ and a set
$$ R = \set{u : u \in \Z^2, x_{\min} \le \x{u} \le x_{\max}, y_{\min} \le \y{u} \le y_{\max}}. $$
We classify $U$ into one of three types:
\begin{enumerate}[a)]
	\item if $U \cap \Ta = \emptyset$ then $U$ is an inactive tile,
	\item if $U \cap \Ta \neq \emptyset$, $R \not \subseteq \Ta$ then $U$ a border tile,
	\item if $U \cap \Ta \neq \emptyset$, $R \subseteq \Ta$ then $U$ is an active tile.
\end{enumerate}
We define $B$ as a set of all $u \in \Ta$ contained in a border tile and construct $F = (B, \f{T})$.
Let us denote $z = \frac{n - 1}{2}$.
Consider a family of sets $\mathcal{R} = \set{R^1_i} \cup \set{R^2_i} \cup \set{R^3_i} \cup \set{R^4_i}$,
where for every active tile $U$ with coordinates $(s, t)$ its members are placed into exactly one subset:
\begin{enumerate}[1)]
	\item $R^1_{t}$ if $y_{\min} > z$, $x_{\max} \ge z$,
	\item $R^2_{s}$ if $x_{\max} < z$, $y_{\max} \ge z$,
	\item $R^3_{t}$ if $y_{\max} < z$, $x_{\min} \le z$,
	\item $R^4_{s}$ if $x_{\min} > z$, $y_{\min} \le z$.
\end{enumerate}
The number of non-empty sets $R \in \mathcal{R}$ is $\O(\ell)$.
For each of them we consider $S = (R, \f{T})$ which is a simple parquet string with $\O(k)$-periods $\phi$ and $\psi$,
and we further partition it using algorithm from \Cref{parquet_decomposition}, thus constructing the set $\U$.


% SPARSE HAMMING
\newcommand{\W}{\mathcal{W}}
\subsection{Proof of \Cref{sparse_algo}}
Throughout this section we will denote $D = \set{u : u \in \L, \h{u} \ge 0, \s{u} \ge 0}$, where $\L$ is the set introduced in \Cref{lattice_congruency}.

\begin{lemma}\label{primitive_conv}
	Given a set of subparquets $\V$ and a set of points $Q$, we can calculate
	$$ \sum_{V \in \V} |(D + q) \cap V| $$
	for every $q \in Q$ in total time $\tO(n^2 + |Q| + |\V|)$ assuming that every $V \in \V$ consists of vectors of length $\O(n)$.
	\begin{proof}
		For every $u \in \Z^2$ let us define $\score(u) = |\set{V : V \in \V, u \in V}|$. Observe that
		$$ \sum_{V \in \V} |(D + q) \cap V| = \sum_{u \in D + q} \score(u). $$
		We start by explicitly calculating the scores.
		We find the maximum length of a vector that some $V \in \V$ is defined for, which we denote $\ell$.
		We construct the set $U \subseteq \Z^2$ of all vectors of length at most $\ell$.
		By the assumption, we have $\ell = \O(n)$, and thus $|U| = \O(l ^ 2) = \O(n ^ 2)$.
		We observe that since all the scores are zero for points outside of $U$, we can only calculate them for $u \in U$.
		
		We find the set $\Gamma$ introduced in \Cref{lattice_base} and for every $\gamma \in \Gamma$ we construct $U_\gamma = U \cap (\L + \gamma)$.
		Consider any $u \in U_\gamma$ for some fixed $\gamma \in \Gamma$ and any $V \in \V$.
		We observe that if $V \not \equiv \gamma$, then $u \not \in V$ and thus $V$ does not contribute to $\score(u)$.
		If $V \equiv \gamma$, then we can find a parquet $W$ such that $V = W \cap (\L + \gamma)$ and we have
		$u \in V \Leftrightarrow u \in W \cap (\L + \gamma) \Leftrightarrow u \in W$.
		Thus, if we denote $\W_\gamma$ as the set of parquets $W$ obtained for every $V \in \V$ such that $V \equiv \gamma$, then $\score(u)$ for $u \in U_\gamma$ is the number of parquets $W \in \W_\gamma$ such that $u \in W$.
		We calculate $\score(u)$ for every $u \in U_\gamma$ by sweeping $U_\gamma$ and $\W_\gamma$ in time $\tO(|U_\gamma| + |\W_\gamma|)$.
		We do it independently for every $\gamma \in \Gamma$, performing $\tO(|U| + |\V|) = \tO(n^2 + |\V|)$ operations in total.

		Now consider a query vector $q \in Q$.
		Let $\gamma \in \Gamma$ be such that $q \equiv \gamma$.
		We have already showed that the sum of scores for $u \in D + q$ is equal to the sum of scores for $u \in (D + q) \cap U$.
		Since $(D + q) \cap U = (D + q) \cap U_\gamma$, we see that the result is the sum of scores for $u \in U_\gamma$ such that $\h{u} \ge \h{q}$ and $\s{u} \ge \s{q}$.
		If we denote $Q_\gamma = Q \cap (\L + \gamma)$, we see that we can calculate the results for all $q \in Q_\gamma$ by sweeping $Q_\gamma$ and $U_\gamma$ in time $\tO(|Q_\gamma| + |U_\gamma|)$.
		We do it independently for every $\gamma \in \Gamma$, performing $\tO(|Q| + |U|) = \tO(n^2 + |Q|)$ operations in total.
	\end{proof}
\end{lemma}

\begin{lemma}\label{primitive}
	For any simple subparquet $U$ we can find $w_0, \dots, w_3 \in \Z^2$ such that
	$$ |U \cap X| = \sum_{j = 0}^3 (-1)^j |(D + w_j) \cap X|$$
	for every $X \subseteq \Z^2$.
	If $U$ consists of vectors of length $\O(n)$, then $w_0, \dots, w_3$ are of length $\O(n)$.
\end{lemma}

We apply \Cref{primitive} to every $U_i$ and find $w_{i, 0}, \dots, w_{i, 3}$ so that we have
\eq{
\sum_{i = 1}^\ell|(U_i + q) \cap V_i| 
= \sum_{i = 1}^\ell|U_i \cap (V_i - q)| 
= \sum_{i = 1}^\ell \sum_{j = 0}^3 (-1)^j |(D + w_{i, j}) \cap (V_i - q)| \\
= \sum_{j = 0}^3 (-1)^j \sum_{i = 1}^\ell |(D + q) \cap (V_i - w_{i, j})|.
}
By \Cref{primitive_conv} we can independently calculate the values $\sum_{i = 1}^\ell |(D + q) \cap (V_i - w_{i, j})|$ for every $j$ by running the algorithm for $\V_j = \set{V_i - w_{i, j} : i \in \set{1, \dots, \ell}}$ and $Q$.

% DENSE HAMMING
\subsection{Proof of \Cref{dense_algo}}


Recall that by \Cref{parquet_decomposition} we can partition $P$ into a set of monochromatic subparquet strings $\V$, where $|\V| = O(k)$.
For every character $\sigma \in \Sigma$ present in $P$ we construct $\V_\sigma = \set{V : V \in \V, \getchar{V} = \sigma}$.
We call $\sigma$ a \textbf{frequent} character if $|\V_\sigma| \ge \sqrt{k}$ and if $|\V_\sigma| < \sqrt{k}$, we call it an \textbf{infrequent} character.
We partition $F$ into two strings $S$ and $R$, where $S(u)$ is a frequent character for every $u \in S$ and $R(u)$ is an infrequent character for every $u \in R$.

For every $q \in Q$ we then have $\Ham(P + q, F) = \Ham(P + q, S) + \Ham(P + q, R)$, which we calculate independently.

\subsubsection{Frequent character contribution}
We show how to calculate $\Ham(P + q, S)$ for every $q \in Q$.
We start by partitioning $S$ into four strings $S_1, \dots, S_4$ by splitting through the middle with a horizontal and vertical line.
Specifically
\begin{itemize}
	\item $S_1$ is the restriction of $S$ to $\set{0, \dots, n / 2 - 1} \times \set{0, \dots, n / 2 - 1}$,
	\item $S_2$ is the restriction of $S$ to $\set{0, \dots, n / 2 - 1} \times \set{n / 2, \dots, n - 1}$,
	\item $S_3$ is the restriction of $S$ to $\set{n / 2, \dots, n - 1} \times \set{n / 2, \dots, n - 1}$,
	\item $S_4$ is the restriction of $S$ to $\set{n / 2, \dots, n - 1} \times \set{0, \dots, n / 2 - 1}$.
\end{itemize}
We independently calculate $\Ham(P + q, S_i)$ for every $i$ and sum the results.
We show how to calculate $\Ham(P + q, S_1)$ for every $q \in Q$.
The other components can be handled similarly.

We will take advantage of the fact that the points close to the border can overlap only with a small subset of points from the pattern when considering the occurrences fully contained in the active text.
Specifically, consider a set $J = [d] \times [n] \cup [n] \times [d]$ and a string $P_J = \restr{P}{J}$. 

\begin{lemma}
	$\Ham(P + q, S_1) = \Ham(P_J + q, S_1)$ for every $q \in Q$.
\end{lemma}

\begin{theorem}\label{column_cutting}
	We can partition $S_1$ into $\O(m / d)$ strings such that their width is $\O(d)$ and the sum of their heights is $\O(m)$.
\end{theorem}


\subsubsection{Proof of \Cref{column_cutting}}
Consider an array of strings $U_0, \dots, U_{\lceil n / d \rceil - 1}$ where $U_i$ is the restriction of $S_1$ to $\set{id, \dots, id + d - 1} \times [n] \cap \d{S_1}$.
For the sake of formality (since the maximum/minimum of an empty set is undefined) we construct an array of strings $V_0, \dots, V_{\ell - 1}$ consisting of all non-empty strings $U_i$, given in the ascending order of $i$.
Observe that $V_0, \dots, V_{\ell - 1}$ partition $S_1$, their width is $\O(d)$ and it remains to show that the sum of their heights is $\O(m)$.
Let us denote $a_i = \min \set{\y{u} : u \in V_i}$ and $b_i = \max \set{\y{u} : u \in V_i}$.
Our goal is to prove that $\sum_{i = 0}^{\ell - 1} b_i - a_i + 1 = \O(m)$.
\begin{lemma}
	$b_{i + 2} - a_i \le d$ for every $i < \ell - 2$.
	\begin{proof}
		Let us assume the contrary and have $b_{i + 2} - a_i > d$ for some $i$.
		There exists $u \in V_i$ such that $\y{u} = a_i$ and $v \in V_{i + 2}$ such that $\y{v} = b_{i + 2}$.
		We have $\y{v} - \y{u} > d$ (by assumption) and $\x{v} - \x{u} > d$ (since $u \in V_i$, $v \in V_{i + 2}$).
	\end{proof}
\end{lemma}

\subsubsection{Infrequent character contribution}



\bibliographystyle{plain}
\bibliography{references}

\end{document}
