\documentclass[11pt]{article}
\pdfoutput=1
\usepackage[margin=1in,a4paper]{geometry}
\usepackage{amsthm,amssymb,amsmath}  
\usepackage{xspace,enumerate}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks=true,urlcolor=Blue,citecolor=Green,linkcolor=BrickRed]{hyperref}
\usepackage[capitalise]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{authblk}


\DeclareMathOperator*{\Ham}{Ham}
\DeclareMathOperator*{\ID}{Id}
\def\dd{\mathinner{.\,.}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\tO}{\tilde{\mathcal{O}}}
\renewcommand{\phi}{\varphi}
\newcommand{\set}[1]{\left\lbrace #1 \right\rbrace}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\bigset}[1]{\big \lbrace #1 \big \rbrace}
\newcommand{\Bigset}[1]{\Big \lbrace #1 \Big \rbrace}
\newcommand{\eq}[1]{\begin{align*} #1 \end{align*}}
\newcommand{\defproblem}[3]{\begin{center}\vspace{2mm}\noindent\fbox{\begin{minipage}{0.96\textwidth} #1 \\ {\bf{INPUT:}} #2 \\ {\bf{OUTPUT:}} #3 \end{minipage}} \vspace{2mm}\end{center}}


\usepackage{microtype} %if unwanted, comment out or use option "draft"
\usepackage{amsmath,amsfonts}
\usepackage[cmbtt]{bold-extra}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{thm-restate}
\usepackage{comment}
\usepackage{forest}
\usepackage{xspace}
\usepackage{enumerate}
\usepackage{makecell}
\usepackage{listings}
\usepackage{multirow}
\usepackage{diagbox}
\usepackage{todonotes}
\usepackage{thmtools}
\usepackage[ruled,noline,noend]{algorithm2e}
\usepackage[capitalise]{cleveref}
\usepackage{graphics,adjustbox}
\usepackage{tabularx}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{verbatim}
\usepackage{braket}
\usepackage[noadjust]{cite}
\usepackage{xspace}
\usepackage{bold-extra}
\usepackage[margin=1in]{geometry}

\pagestyle{myheadings}


\title{Fast algorithm for two-dimensional pattern matching with $k$ mismatches}
\author[1]{Jonas Ellert}
\author[2]{Paweł Gawrychowski}
\author[3]{Adam Górkiewicz}
\author[4]{Tatiana Starikovskaya}
\affil[1]{?}
\affil[2]{?}
\affil[3]{?}
\affil[4]{?}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}  
\newtheorem{fact}{Fact}
\newtheorem{corollary}[fact]{Corollary}  
\newtheorem{observation}{Observation}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Conjecture} 
\newtheorem*{claim}{Claim}
\newtheorem{problem}{Problem}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}


\sloppy

\DeclareMathOperator*{\dom}{dom}
\newcommand{\restr}[2]{#1\restriction_{#2}}

% BEGIN DOCUMENT
\begin{document}

\date{}
\maketitle

\begin{abstract}
\end{abstract}

%\thispagestyle{empty}
%\clearpage
%\setcounter{page}{1}


% INTRODUCTION
\section{Introduction}

\newcommand{\hd}{\textsc{HD1D}\xspace}
\newcommand{\HD}{\textsc{HD2D}\xspace}

We consider the one-dimensional all-substring Hamming distance problem (\hd), where for a given text string $T$ of length $n$ and a string $P$ of length $m$ ($m < n$), we want to calculate the Hamming distance between $P$ and every fragment $T$ of length $m$.

We consider the two-dimensional all-substring Hamming distance problem (\HD), where for a given 2D string $T$ of size $n \times n$ and a string $P$ of size $m \times m$ ($m < n$), we want to calculate the Hamming distance between $P$ and every $m \times m$ fragment of $T$.

We also consider the bounded variants of \hd and \HD, where we are only required to calculate the distances which are not greater than $k$, for some parameter $k \in \Z^+$.


\begin{theorem}[Main result]\label{main result}
	Bounded \HD can be solved in $\tO((m^2 + mk^{5/4})n^2 / m^2)$ time.
\end{theorem}


% PRELIMINARIES
\section{Preliminaries}

For our purposes we will not use the standard definition of a two-dimensional string, where we associate it with a two-dimensional array of characters, and instead we will define it more broadly.
Although we will occasionally use the array notation, we will do it exclusively for $n \times m$ strings.
In all sections we will only consider integer points or vectors and we will use these terms interchangeably.
We will denote $[n] = \set{0, \dots, n - 1}$ for any $n \in \Z^+$.
Our results hold under word-RAM model of computation.

\newcommand{\pto}{\mathrel{\ooalign{\hfil$\mapstochar\mkern5mu$\hfil\cr$\to$\cr}}}
\renewcommand{\d}[1]{\dom(#1)}
\newcommand{\f}[1]{#1^\mathbf{f}}
\begin{definition}[Two-dimensional string]
	We define a \textbf{string} $S$ as a partial function $\Z^2 \pto \Sigma$ which maps some set of points denoted as $\d{S}$ to characters.
	For simplicity we will write $u \in S$ to denote that $u \in \d{S}$.
	We say that a string $S$ is \textbf{partitioned} into strings $R_1, \dots, R_\ell$ when the sets $\d{R_1}, \dots, \d{R_\ell}$ partition $\d{S}$ and $R_i(u) = S(u)$ for all $u \in R_i$.
	We call a string $S$ \textbf{monochromatic} when it is constant on its domain.
	We say that $S$ is $n \times m$ for some $n, m \in \Z^+$ when $\d{S} = [n] \times [m]$.
	Physically we represent a string as a list of point-character pairs.
\end{definition}


\begin{definition}[Shifting]
	For a set of points $V \subseteq \Z^2$ and a vector $u \in \Z^2$, we denote $V + u$ as $\set{v + u : v \in V}$.
	For a string $S$ and a vector $u \in \Z^2$ we denote $S + u$ as a string $R$ such that
	$\d{R} = \d{S} + u$ and $R(v) = S(v - u)$ for $v \in \d{R}$.
	Intuitively, we shift the set of points while maintaining their character values.
\end{definition}


\begin{definition}[Hamming distance]
	Consider two strings $S, R$. We define
	$$ \Ham(S, R) = |\set{u : u \in \d{S} \cap \d{R}, S(u) \neq R(u)}|.$$
\end{definition}


Under such notation, the \HD problem is equivalent to calculating the (bounded or unbounded) values of $ \Ham(P + q, T) $
for all $q \in \Z^2$ such that $\d{P + q} \subseteq \d{T}$ (so for $q \in [n - m]^2$).


\begin{definition}[Don't care symbol]
	We define the \textbf{don't care} symbol as a special character which matches with every character.
	We will denote it with \texttt{?}.
	Unless stated otherwise, we assume it is not allowed in $\Sigma$ and in both \hd and \HD every character present in $T$ and $P$ matches only with itself.
\end{definition}


\newcommand{\x}[1]{#1.x}
\newcommand{\y}[1]{#1.y}
\newcommand{\h}[1]{\phi \times #1}
\newcommand{\s}[1]{\psi \times #1}
\begin{definition}[Vector operators]
	For any $u \in \Z^2$ we refer to its coordinates as $\x{u}, \y{u}$.
	For $u, v \in \Z^2$ we denote $u \cdot v = \x{u} \cdot \x{v} + \y{u} \cdot \y{v}$
	and $u \times v = \x{u} \cdot \y{v} - \y{u} \cdot \x{v}$.
	Note that alternatively $u \cdot v = |u||v| \cos \alpha$ and $u \times v = |u||v| \sin \alpha$ where $\alpha$ is the angle between $u$ and $v$.
\end{definition}


\newcommand{\Q}{\mathcal{Q}}
\begin{definition}[Quadrants]
	We define the four \textbf{quadrants} as
	\eq{
		\Q_1 &= (0, +\infty) \times [0, +\infty), \\
		\Q_2 &= (-\infty, 0] \times (0, +\infty), \\
		\Q_3 &= (-\infty, 0) \times (-\infty, 0], \\
		\Q_4 &= [0, +\infty) \times (-\infty, 0).
	}
\end{definition}


\section{One-dimensional generalizations}
In this section we explore some of the methods used for one-dimensional strings.
Specifically, as our goal is to generalize the solution for pattern matching with $k$ mismatches described in \cite{Gawrychowski2017}, we are especially interested in two-dimensional variants of the techniques that were used to solve the one-dimensional case.


\begin{theorem}[Instancing]\label{instancing}
	Consider an algorithm $\mathcal{A}$ which solves \HD (bounded or unbounded), but only when $2|n$ and $n \le \frac{3}{2}m$.
	If its running time is $\mathcal{T}(m)$, then the general case can be solved in $\O(\mathcal{T}(m) n^2 / m^2)$.
	\begin{proof}
		Let $r = \floor{m / 2}$ and let $n' = r + m - 1$ or $r + m$ if $r + m - 1$ is odd.
		We see that the set $N = [n']^2$ satisfies the conditions for the text domain.
		For any vector $q \in [n - m]^2$ we can find a vector $u$ such that $r|u.x, r|u.y$ and $q - u \in [r]^2$,
		so we have $\Ham(P + q, T) = \Ham(P + q - u, T_u)$ where $T_u = \restr{(T - u)}{N}$.
		If $T - u$ is not defined for some $v \in N$, we can pad $T_u(v)$ with any character.
		We can see that $\d{P + q - u} \subseteq N = \d{T_u}$.
		There are $\O(n^2 / m^2)$ possible vectors $u$ and we run $\mathcal{A}$ for every pair of $T_u$ and $P$.
	\end{proof}
\end{theorem}


\begin{theorem}[Kangaroo jumps]\label{kangaroos}
	Consider an $n \times n$ string $T$, $m \times m$ string $P$ and set of vectors $Q$ such that $\d{(P + q)} \subseteq \d{T}$ for every $q \in Q$.
	There exists an algorithm which calculates $ d_q = \Ham(P + q, T) $ for every $q \in Q$ in total time $\tO(n^2 + \sum_{q \in Q} d_q)$.
	\begin{proof}
		For the sake of clarity of this proof, we will temporarily switch to the classical array notation for strings.
		Let $T_0, \dots, T_{n - m}$ denote an array of two-dimensional strings (arrays) such that $T_k[0 \dd n - 1, 0 \dd m - 1] = T[0 \dd n - 1, k \dd k + m - 1]$.
		For every row $P[0], \dots, P[m - 1]$ of $P$ and every row $T_k[0], \dots, T_k[n - 1]$ of every $T_k$ we assign an integer identifier so that $\ID(P[i]) = \ID(T_k[j]) \Leftrightarrow P[i] = T_k[j]$ using KMR algorithm ([reference]) in $\tO(n^2)$.
		
		We use the approach described in [kangaroo reference].
		There exists a data structure (suffix array) which for a given one-dimensional array $S$ allows us to detect all mismatches between any given two of its subarrays of equal length.
		It can be built in $\tO(|S|)$ and the query time is $\tO(d)$ where $d$ is the number of mismatches.
		We construct the suffix array for the concatenation of the following arrays:
		\begin{itemize}
			\item the rows $P[i]$ for every $i$,
			\item the rows $T[i]$ for every $i$,
			\item the array $\ID(P[0]) \ID(P[1]) \dots \ID(P[m - 1])$,
			\item the arrays $\ID(T_k[0]) \ID(T_k[1]) \dots \ID(T_k[n - 1])$ for every $k$,
		\end{itemize}
		the total length of which is $\O(n^2)$.
		Let us consider a problem of detecting mismatches between $P$ and some $T' = T[j \dd j + m - 1, k \dd k + m - 1]$.
		We can firstly detect all such $i$ for which $P[i] \neq T'[i]$ by querying the subarrays $\ID(P[0]) \dots \ID(P[m - 1])$ and $\ID(T_k[j]) \dots \ID(T_k[j + m - 1])$.
		For every such $P[i] \neq T'[i]$ we can then find all mismatches by querying $P[i]$ and $T[i + j][k \dd k + m - 1]$.
	\end{proof}
\end{theorem}


\begin{fact}\label{sigman1d}
	There exists an algorithm which solves \hd in $\tO(n|\Sigma|)$ time.
	It works by simply running $|\Sigma|$ instances of FFT.
	It allows don't care symbols in $T$ and $P$.
\end{fact}


\begin{fact}\label{approx1d}
	There exists a $(1 + \varepsilon)$-approximate algorithm which solves \hd in $\tO(n)$ time.
	It was introduced in \cite{Karloff1993}.
	It allows don't care symbols in $T$ and $P$.
\end{fact}


\begin{theorem}\label{sigman2d}
	There exists an algorithm which solves \HD in $\tO(n^2|\Sigma|)$ time.
	It allows don't care symbols in $T$ and $P$.
	\begin{proof}
		We will again use the array notation.
		We construct one-dimensional strings $\bar{T}$ and $\bar{P}$ by concatenating subsequent rows $T[0], \dots, T[n - 1]$ of $T$ and rows $P[0], \dots, P[m - 1]$ of $P$ padded with some don't care symbols:
		\eq{
			\bar{T} &= T[0] \ \texttt{?}^{m} \ T[1] \ \texttt{?}^{m} \ \dots \ \texttt{?}^{m} \ T[n - 1] \ \texttt{?}^{m}, \\
			\bar{P} &= P[0] \ \texttt{?}^{n} \ P[1] \ \texttt{?}^{n} \ \dots \ \texttt{?}^{n} \ P[m - 1] \ \texttt{?}^{n}.
			}                                                                          
		We run the algorithm from Fact \ref{sigman1d}.
		The distance between $T[i \dd i + m - 1, j \dd j + m - 1]$ and $P$ is equal to the distance between $\bar{T}[i(n + m) + j \dd (i + m)(n + m) + j - 1]$ and $\bar{P}$ for every $i, j$.
	\end{proof}
\end{theorem}


\begin{theorem}\label{approx2d}
	There exists a $(1 + \varepsilon)$-algorithm which solves \HD in $\tO(n^2)$ time.
	It allows don't care symbols in $T$ and $P$.
	\begin{proof}
		Identical to Theorem \ref{sigman2d}., but we use the algorithm from Fact \ref{approx1d}. instead of \ref{sigman1d}.
	\end{proof}
\end{theorem}


\begin{remark}
	The same reduction as in Theorem \ref{sigman2d}. can be applied for every \hd solution which allows don't care symbols.
	Unfortunately, the most effective known algorithms for bounded \hd rely on periodicity (\cite{Clifford2015}, \cite{Gawrychowski2017}) and inherently do not allow don't care symbols, thus, they cannot be easily generalized.
\end{remark}


\begin{observation}[Don't care padding]
	Every \HD solution which allows don't care symbols (eg. the algorithms from Theorem \ref{sigman2d}. and \ref{approx2d}.) can be extended to also calculate the Hamming distance for occurrences of $P$ which are not entirely contained in $T$.
	It can be done by padding the text with don't care symbols and it does not change the complexity of the solution.
\end{observation}


% MAIN ALGORITHM
\section{Proof of Theorem \ref{main result}.}
We show an algorithm which works in time $\tO(m^2 + mk^{5/4})$ assuming $2|n$ and $m < n \le \frac{3}{2}m$.
By Theorem \ref{instancing}., our thesis will follow.

We start by running the algorithm from Theorem \ref{approx2d}. with $\varepsilon = 1$.
We construct the set $Q$ as the set of such vectors $q \in \Z^2$ for which the estimated value of $\Ham(P + q, T)$ is at most $2k$.
For every $q \in \set{0, \dots, n - m}^2 \setminus Q$ we say that $\Ham(P + q, T)$ equals $\infty$.
The next step is to calculate the exact value of $\Ham(P + q, T)$ for every $q \in Q$.

Let us consider the case when $|Q| \le 2m + m^2/k$.
We can run the algorithm from Theorem \ref{kangaroos}. and by the fact that $\Ham(P + q, T) \le 4k$ for every $q \in Q$, it will perform $\tO(m^2 + mk)$ operations.
We are left with the case when $|Q| > 2m + m^2/k$, in which we take advantage of the fact that some strings $P + q$ for $q \in Q$ must have a large overlap and small Hamming distance from each other, and thus $P$ must be periodic.


\newcommand{\T}{\mathcal{T}}
\renewcommand{\S}{\mathcal{S}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\L}{\mathcal{L}}


% 2D PERIODICITY
\subsection{Two-dimensional periodicity}
In this section we introduce a range of new tools related to two-dimensional periodicity.
We then select some special periods of the pattern and show how to decompose it into some regularly structured monochromatic strings.


\begin{definition}[Periodicity]
	Consider any vector $\delta \in \Z^2$.
	We say that a string $S$ has an $\ell$-period $\delta$ when
	$$ \Ham(S + \delta, S) \le \ell. $$
\end{definition}


\begin{lemma} \label{periodicity_lemma}
	For every $u, v \in Q$, the vector $u - v$ is an $8k$-period of $P$.
	\begin{proof}
		$\Ham(P + u - v, P) = \Ham(P + u, P + v) \le \Ham(P + u, T) + \Ham(P + v, T) \le 4k + 4k. $
	\end{proof}
\end{lemma}


\begin{theorem}
	\label{get_periods}
	For an integer $\ell > 0$ and a set of vectors $U \subseteq \set{0, \dots, \ell}^2 $ such that $|U| > 4\ell$ there exist $s, t, s', t' \in U$ such that $w = t - s$ and $w' = t' - s'$ hold the following conditions:
	\begin{itemize}
		\item $0 < |w||w'| \le 22\frac{\ell^2}{|U|}$,
		\item $|\sin \alpha| \ge \frac{1}{2}$ where $\alpha$ is the angle between $w$ and $w'$,
		\item $w, w', -w, -w'$ are all contained in different quadrants.
	\end{itemize}
	There exists an algorithm which finds such $w, w'$ in $\tO(|U|)$ operations.
\end{theorem}


We run Algorithm \ref{get_periods}. on the set $Q$ (where $\ell = n - m \le m / 2$, thus $|Q| > 2m + m^2/k \ge 4\ell$).
We obtain vectors $\phi \in \Q_4$ and $\psi \in \Q_1$ which by Lemma~\ref{periodicity_lemma}. are $\O(k)$-periods of $P$.
We use them as constants throughout the rest of the description along with $p = \phi \times \psi$.
Note that because $|Q| > m + m^2 / k$, we have $p \le |\phi||\psi| = \O(\min\set{m, k})$.


\begin{definition}[Lattice congruency]
	We say that two vectors $u, v \in \Z^2$ are \textbf{lattice congruent} and denote $u \equiv v$ when there exist $s, t \in \Z$ such that $u - v = s\phi + t\psi$.
\end{definition}


\begin{lemma}[Lattice base]\label{lattice_base}
	There exists an array $\gamma_1, \dots, \gamma_p \in \Z^2$ such that $\gamma_i \not \equiv \gamma_j$ for $i \neq j$ and for every $u \in \Z^2$ there exists $\gamma_i$ such that $u \equiv \gamma_i$.
\end{lemma}


\begin{definition}[Parquet]
	Consider a set $U \subseteq \Z^2$. We call $U$ a \textbf{parquet} if there exist some values (restrictions) $x_0, x_1, y_0, y_1, \phi_0, \phi_1, \psi_0, \psi_1 \in \Z$ such that
	$$ U = \set{u : u \in \Z^2, x_0 < \x{u} \le x_1, y_0 < \y{u} \le y_1, \phi_0 < \h{u} \le \phi_1, \psi_0 < \s{u} \le \psi_1}. $$
	If some existing restrictions hold additional conditions, we classify $U$ as a special case of parquet:
	\begin{enumerate}[a)]
		\item if $x_1 - x_0 \ge |\x{\phi}| + |\x{\psi}|$ and $y_1 - y_0 \ge |\y{\phi}| + |\y{\psi}|$, then we call $U$ a \textbf{spacious} parquet,
		\item if $x_0, y_0 = -\infty$ and $x_1, y_1 = +\infty$, then we call $U$ a \textbf{simple} parquet,
		\item if $x_0, y_0, \phi_0, \psi_0 = -\infty$ and $x_1, y_1 = +\infty$, then we call $U$ a \textbf{primitive} parquet.
	\end{enumerate}
	Note that every primitive parquet is simple and every simple parquet is spacious.
\end{definition}


\begin{definition}[Subparquet]
	Consider a set $V \subseteq \Z^2$. 
	We call $V$ a \textbf{subparquet} if there exist a parquet $U$ and a vector $\gamma \in \Z^2$ such that
	$$ V = \set{u : u \in U, u \equiv \gamma}.$$
	We call $V$ a spacious/simple/primitive subparquet when there exists $U$ which is (correspondingly) a spacious/simple/primitive parquet.
	We will abuse the notation and for non-empty $V$ write $u \equiv V$ to (unambiguously) denote that $u \equiv \gamma$ for some vector $u \in \Z^2$. 
\end{definition}


\begin{definition}[Parquet string]
	For a string $S$, if $\d{S}$ is a spacious/simple (sub-)parquet, then we call $S$ a spacious/simple (sub-)parquet string.
\end{definition}


\begin{theorem}[Periodic parquet decomposition]\label{parquet_decomposition}
	Consider a spacious/simple parquet string $R$ with $\O(k)$-periods $\phi$ and $\psi$.
	It can be partitioned into $\O(k)$ monochromatic spacious/simple subparquet strings, correspondingly.
	There exists an algorithm which finds this partitioning in $\tO(|\d{R}|)$ operations.
\end{theorem}


Since $|\x{\phi}|, |\y{\phi}|, |\x{\psi}|, |\y{\psi}| \le n - m \le m / 2$, the $m \times m$ string $P$ is a spacious parquet string and satisfies the assumptions of Theorem \ref{parquet_decomposition}.
We partition $P$ into a set of monochromatic spacious parquet strings $\V$, where $|\V| = \O(k)$.
Note that because the text is not necessarily periodic, we unfortunately cannot use the same approach for $T$.


% TEXT DECOMPOSITION
\subsection{Text decomposition}
In this section we show how to decompose the text using a similar but more nuanced approach.
We then introduce an effective way to aggregate the contributions of every pair of strings that $P$ and $T$ are decomposed into.


\newcommand{\Ta}{T_a}
\newcommand{\Tb}{T_b}
\begin{definition}[Active text]
	Consider a set $U = \bigcup_{q \in Q} \d{P} + q$. 
	We define strings $\Ta = (U, \f{T})$ and $\Tb = (\d{T} \setminus U, \f{T})$.
	We will call $\Ta$ the \textbf{active text} and $\Tb$ the \textbf{inactive text}.
	For every $u \in \Z^2$ we define its \textbf{border distance} as
	$$\min\set{\|u - v\|_\infty : v \in (\Z^2 \setminus U)}.$$
\end{definition}


\begin{observation}
	$\Ham(P + q, T) = \Ham(P + q, \Ta)$ for every $q \in Q$.
\end{observation}


\begin{theorem}[Active text decomposition]\label{text_decomposition}
	There exists an algorithm which for any $\ell = \O(m)$ partitions $\Ta$ into a set of monochromatic simple subparquet strings $\U$ and a string $F$,
	such that $|\U| = \O(\min\set{m^2, \ell k})$ and for every $u \in F$ its border distance is $\O(m / \ell)$.
	It does so in $\tO(m^2)$ operations.
\end{theorem}


\begin{theorem}[Sparse Hamming]\label{sparse_algo}
	Consider a set of monochromatic simple subparquet strings $\U$, a set of monochromatic subparquet strings $\V$ and a set of vectors $Q$.
	There exists an algorithm which calculates
	$$ \sum_{U \in \U}\sum_{V \in \V} \Ham(U + q, V) $$
	for every $q \in Q$ in time $\tO(\ell^2 + |\U||\V| + |Q|)$ assuming that all strings are defined for vectors with coordinate values from $\set{0, \dots, \ell}$ for some $\ell \in \Z^+$.
\end{theorem}


\begin{theorem}[Dense Hamming]
	\label{dense_algo}
	Consider a string $F$ such that for every $u \in F$ its border distance is less than $\ell$ for some $\ell \in \Z^+$.
	There exists an algorithm which calculates $\Ham(P + q, F)$ for every $q \in Q$ in total time $\tO(m^2 + m \ell k^{1/2})$.
	%Note that $P$, $Q$ and border distance are specific to our instance.
\end{theorem}


We partition $\Ta$ using the algorithm from Theorem \ref{text_decomposition}. with $\ell = mk^{-3/4}$ into a set of simple subparquet strings $\U$ and a string $F$.
For every $q \in Q$ we then have
$$ \Ham(P + q, \Ta) = \Ham(P + q, F) + \sum_{U \in \U}\sum_{V \in \V} \Ham(U - q, V) $$
which we calculate by summing the results of algorithms from Theorem \ref{dense_algo}. and Theorem \ref{sparse_algo}.


% PHI PSI FINDER
\subsection{Proof of Theorem \ref{get_periods}.}
Firstly, we find any closest pair of vectors $s, t \in U$ by running the standard $\tO(|U|)$ time algorithm and denote $w = t - s$.
We define a partial order $\le_{w}$ where $v \le_w u$ for some $u, v \in U$ when at least one condition holds:
\begin{enumerate}[(a)]
	\item $u = v$,
	\item $u - v$ and $w$ belong to the same quadrant,
	\item $\alpha \in (-\frac{\pi}{6}, \frac{\pi}{6})$ where $\alpha$ is the angle between $w$ and $u - v$.
\end{enumerate}
We find the longest chain $C$ and the longest antichain $A$ using dynamic programming in $\tO(|U|)$ operations.
We then find any closest pair of vectors $s', t' \in A$ and denote $w' = t' - s'$.
We have the following inequalities:
\begin{enumerate}[(i)]
	\item $|U| \le |C| |A|$ (by Dilworth's theorem),
	\item $(|C| - 1) |w| \le (1 + \sqrt{3})\ell$ (roughly by the fact that vectors in $C$ must be increasing in a certain direction), 
	\item $(|A| - 1) |w'| \le 2 \ell$ (by using a similar argument for vectors in $A$).
\end{enumerate}
By considering the assumption $|U| > 4\ell$ it can be proven that $|w||w'| \le 22 \frac{\ell^2}{|U|}$ and the other conditions also hold.


% PARQUET DECOMPOSITION
\subsection{Proof of Theorem \ref{parquet_decomposition}.}


\begin{definition}[Lattice graph]
	For a set $U \subseteq \Z^2$ we define its \textbf{lattice graph} $G_U = (U, E_U)$ where
	$$ E_U = \bigset{\set{u, u + \delta} : \delta \in \set{\phi, \psi}, u \in U, u + \delta \in U} $$ 
	so every vector is connected with its translations by $\phi, \psi, -\phi, -\psi$.
\end{definition}


\begin{lemma}
	If $U$ is a spacious subparquet, then $G_U$ is connected.
\end{lemma}


Firstly, we partition $R$ into a set of subparquet strings $\S$.
For every non-empty $S \in \S$ we consider a lattice graph $G_{\d{S}}$. If $S$ is not monochromatic, then since $G_{\d{S}}$ is connected, there must exist a pair of neighboring vectors $v, w$ such that $S(v) \neq S(w)$.
We select any such pair and partition $S$ into spacious (or simple if $S$ is simple) subparquet strings $S'$ and $S''$ such that $v \in S'$ and $w \in S''$.
For example if $v = w + \phi$, then $S' = \set{u : u \in S, \s{u} \le \s{v}}$ and $S'' = \set{u : u \in S, \s{u} > \s{v}}$.
In the cases when $v = w + \delta$ for $\delta \in \set{-\phi, \psi, -\psi}$ the construction in similar.

We can recursively partition $S'$ and $S''$ further until we obtain monochromatic strings.
Because $R$ has $\O(k)$-periods $\phi$ and $\psi$, the total number of neighbor pairs $v, w$ such that $S(v) \neq S(w)$ is $\O(k)$ throughout all $S \in \S$.
Thus the total number of recursive calls is $\O(k)$ and because $|\S| = \O(k)$, the total number of constructed strings is $\O(k)$.
The algorithm can be implemented to work in time $\tO(|\d{R}|)$.


% TEXT DECOMPOSITION
\subsection{Proof of Theorem \ref{text_decomposition}.}


We assume $\ell$ to be an even number smaller than $\frac{n}{4}$ (if it is not, we can find $\ell' = \Theta(\ell)$, which is). 
We start by partitioning $\d{T}$ into \textbf{tiles}.
We define $\phi_{\min} = \min \set{\h{u} : u \in \d{T}}$, analogously $\phi_{\max}, \psi_{\min}, \psi_{\max}$ and denote $\delta_{\phi} = \frac{\phi_{\max} - \phi_{\min}}{\ell}$, $\delta_{\psi} = \frac{\psi_{\max} - \psi_{\min}}{\ell}$.
We define a tile with integer coordinates $(s, t)$ as a set of vectors $u \in \Z^2$ such that
$$ \phi_{\min} + s \delta_{\phi} < \h{u} \le \phi_{\min} + (s + 1)\delta_{\phi}, $$ 
$$ \psi_{\min} + t \delta_{\psi} < \s{u} \le \psi_{\min} + (t + 1)\delta_{\psi}. $$
For a fixed tile $U$ consider $x_{\min} = \min \set{\x{u} : u \in U}$, analogously $x_{\max}, y_{\min}, y_{\max}$ and a set
$$ R = \set{u : u \in \Z^2, x_{\min} \le \x{u} \le x_{\max}, y_{\min} \le \y{u} \le y_{\max}}. $$
We classify $U$ into one of three types:
\begin{enumerate}[a)]
	\item if $U \cap \Ta = \emptyset$ then $U$ is an inactive tile,
	\item if $U \cap \Ta \neq \emptyset$, $R \not \subseteq \Ta$ then $U$ a border tile,
	\item if $U \cap \Ta \neq \emptyset$, $R \subseteq \Ta$ then $U$ is an active tile.
\end{enumerate}
We define $B$ as a set of all $u \in \Ta$ contained in a border tile and construct $F = (B, \f{T})$.
Let us denote $z = \frac{n - 1}{2}$.
Consider a family of sets $\mathcal{R} = \set{R^1_i} \cup \set{R^2_i} \cup \set{R^3_i} \cup \set{R^4_i}$,
where for every active tile $U$ with coordinates $(s, t)$ its members are placed into exactly one subset:
\begin{enumerate}[1)]
	\item $R^1_{t}$ if $y_{\min} > z$, $x_{\max} \ge z$,
	\item $R^2_{s}$ if $x_{\max} < z$, $y_{\max} \ge z$,
	\item $R^3_{t}$ if $y_{\max} < z$, $x_{\min} \le z$,
	\item $R^4_{s}$ if $x_{\min} > z$, $y_{\min} \le z$.
\end{enumerate}
The number of non-empty sets $R \in \mathcal{R}$ is $\O(\ell)$.
For each of them we consider $S = (R, \f{T})$ which is a simple parquet string with $\O(k)$-periods $\phi$ and $\psi$,
and we further partition it using algorithm from Theorem \ref{parquet_decomposition}., thus constructing the set $\U$.


% SPARSE HAMMING
\subsection{Proof of Theorem \ref{sparse_algo}.}


Firstly, we assume that all strings in $\U$ nor $\V$ are non-empty.
For $U \in \U$, $V \in \V$, the value $ \Ham(U + q, V)$ either equals $|(\d{U} + q) \cap \d{V}|$ if $U[\d{U}] \neq V[\d{V}]$ or~$0$ otherwise.
We have
$$ \sum_{U \in \U} \sum_{V \in \V} \Ham(U + q, V) = \sum_{(A, B) \in \F} |(A + q) \cap B| $$
where $ \F = \set{(\d{U}, \d{V}) : U \in \U, V \in \V, U[\d{U}] \neq V[\d{V}]} $. 
For every $(A, B) \in \F$ we can find primitive subparquets $A_1, \dots, A_4$ such that for every $q$ we have
$$ |(A + q) \cap B| = |(A_1 + q) \cap B| - |(A_2 + q) \cap B| - |(A_3 + q) \cap B| + |(A_4 + q) \cap B| $$
thus we will consider four instances of a problem of calculating $\sum_{(A, B) \in \F'} |(A + q) \cap B|$ where $A$ is a primitive subparquet and $B$ is a subparquet for all $(A, B) \in \F'$.

We will write $u \le_{\phi\psi} v$ to denote that $\h{u} \le \h{v} \wedge \s{u} \le \s{v}$ for some $u, v \in \Z^2$.


\begin{theorem}\label{sweeper}
	There exists a data structure which for a given set of vectors $U$ and a set of parquets $\S$ calculates
	$$ \sum_{v \in V} |\set{S : S \in \S, v \in S}| $$
	for a given query vector $q$ where $V = \set{v : v \in U, v \le_{\phi\psi} q}$.
	It requires $\tO(|U| + |\S|)$ preprocessing time and $\tO(1)$ query time.
\end{theorem}


We consider the array $\gamma_1, \dots, \gamma_p$ introduced in Lemma \ref{lattice_base}.
We consider an array of data structures $J_1, \dots, J_p$ described in Theorem \ref{sweeper}.
We construct $J_i$ for a set of points $U_i = \set{u : u \in \Z^2, |\x{u}| \le \ell, |\y{u}| \le \ell, u \equiv \gamma_i}$ and set of parquets $\S_i$.
To construct $\S_i$ we consider every pair $(A, B) \in \F'$ and find a vector $w$ and a parquet $V$ such that 
$$ A = \set{u : u \le_{\phi\psi} w, u \equiv w},$$
$$ B = \set{u : u \in (V + w), u \equiv B}.$$
The set $\S_i$ contains the parquets $V$ obtained for pairs $(A, B)$ such that $B - w \equiv \gamma_i$.

For a query vector $q \in \Z^2$ we can obtain the value of $\sum_{(A, B) \in \F'} |(A + q) \cap B|$ by finding $i \in \set{1, \dots, p}$ such that $\gamma_i \equiv q$ and making a query to $J_i$ with vector $q$. 
For explanation, if $A + q \not \equiv B$, then $(A + q) \cap B = \emptyset$.
Otherwise $q \equiv B - w \equiv \gamma_i$ and we have
$$ (A + q) \cap B = \set{u : u \le_{\phi\psi} w + q, u \in (V + w), u \equiv B} = \set{v : v \le_{\phi\psi} q, v \in V, v \equiv \gamma_i}.$$


% DENSE HAMMING
\subsection{Proof of Theorem \ref{dense_algo}.}

To be done.
%	We assume $l$ to be less than $\frac{1}{2}n$.
%	We first partition the string $F$ into four strings:
%	\begin{itemize}
%		\item $F_1 = (\set{0, \dots, \frac{3}{4}n - 1} \times \set{0, \dots, \frac{3}{4}n - 1} \cap \d{F}, \f{F})$
%		\item $F_2 = (\set{0, \dots, \frac{3}{4}n - 1} \times \set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \cap \d{F}, \f{F})$
%		\item $F_3 = (\set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \times \set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \cap \d{F}, \f{F})$
%		\item $F_4 = (\set{\frac{3}{4}n, \dots, \frac{3}{2}n - 1} \times \set{0, \dots, \frac{3}{4}n - 1} \cap \d{F}, \f{F})$
%	\end{itemize}
%	We then independently calculate $\Ham(P + q, F_i)$ for each $i$ and sum the results.
%	
%	To calculate the solution for $\Ham(P + q, F_1)$, let's consider strings of $P$:
%	$$ P_1 = (\set{0, \dots, l - 1} \times \set{0, \dots, n - 1}, \f{P}) $$
%	$$ P_2 = (\set{l, \dots, n - 1} \times \set{0, \dots, l - 1}, \f{P}) $$
%	\begin{lemma}
%		For $q \in Q$ we have
%		$$ \Ham(P + q, F_1) = \Ham(P_1 + q, F_1) + \Ham(P_2 + q, F_2) $$
%	\end{lemma}
%	To calculate $\Ham(P_1 + q, F_1)$ let's partition $F_1$ into strings $\S = \set{S_i}$, where
%	$$ S_i = ((il + \set{0, \dots, l - 1}) \times \Z \cap \d{F_1}, \f{F_1}) $$
%	For every non-empty string $S_i$ let's define $h_i = \max\set{y(u) : u \in S_i} - \min\set{y(u) : u \in S_i}$.
%	\begin{lemma}
%		For every $S_i$ we have
%		$$ \Ham(P_1 + q, S_i) = \Ham(B_i + q, S_i) $$
%		where $B_i = (\Z \times \set{0, \dots, h_i} \cap \d{P_1}, \f{P_1}) $ for non-empty $S_i$, otherwise $B_i$ is empty.
%	\end{lemma}
%	\begin{lemma}
%		The sum of $h_i$ for non-empty sets $S_i$ is $\O(n)$.
%	\end{lemma}
%	\begin{theorem}
%		\label{2dfft}
%		Consider two parquet strings $U$, $V$ such that
%		$$ \max\set{x(u) - x(v) : u, v \in U}, \max\set{x(u) - x(v) : u, v \in V} \le \delta_x $$
%		$$ \max\set{y(u) - y(v) : u, v \in U}, \max\set{y(u) - y(v) : u, v \in V} \le \delta_y $$
%		for some $\delta_x, \delta_y$
%		[TODO what the other conditions have to be, but it's clearly possible for our case].
%		There exists an algorithm which calculates $\Ham(U + q, V)$ for every $q \in \Z^2$ for which it is non-zero (maybe less than $k$).
%		There are $O(\delta_x\delta_y)$ such vectors $q$ and the algorithm takes $\tO(\delta_x\delta_yk^{1/2})$ time.
%	\end{theorem}
%	We have 
%	$$ \Ham(P_1 + q, F_1) = \sum_i \Ham(B_i + q, S_i) $$
%	By using Algorithm \ref{2dfft}. for every non-empty pair $B_i, S_i$, we obtain the total complexity $\tO(nlk^{1/2})$.
%	
%	For $\Ham(P_2 + q, F_1)$ we use the same approach, as well as in the case of $\Ham(P + q, F_2)$, etc.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
